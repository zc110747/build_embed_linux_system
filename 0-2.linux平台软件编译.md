# linux平台软件编译

## 平台软件编译说明

&emsp;&emsp;和linux平台软件安装不同，linux平台软件编译往往需要选择各软件官网的版本进行使用，这里面就涉及版本的选择，这里建议选择最新的LTS版本，所以本文档信息也会随时间而版本落后，就需要自己根据需求更新，对于linux平台软件的编译，可能依赖gcc/g++, make，python2/python3，perl，scons等工具，如果编译时缺失，根据实际情况去下载更新。另外还有一些软件互相依赖某些基础组件如libssl.so, libcrypto.so，libzlib.so，可以使用指令**sudo apt-get install lib[exe].so**进行更新下载，不过即使更新后，也可能因为版本过低不支持某些api导致编译失败，因此这里也会编译一些组件并引入最终程序的编译。<br />
&emsp;&emsp;对于linux平台的软件编译，其实是个很复杂的问题，每个系统都会面临不同的问题，找不到系统头文件，链接找不到库文件，编译器的版本不支持某些编译选项，语法导致直接功能出错，这也是现在很多项目不在直接提供Makefile，反而通过configure先检测系统环境是否支持，在生成Makefile用于编译的脚本，可以提供更加精确的信息，而不是编译时报一大串的错误，没有经验的无从下手，不过找不到头文件或者库文件还是有些技巧的，这里可以说明下，其实这与gcc的编译和链接机制有关。<br />

1. 编译时，在查找-I指定的目录外，还会默认查找目录'/usr/inclue/', 'usr/local/include/'
2. 链接时，除了查找-L指定的目录，还好查找'/lib/','/usr/lib/'和/usr/local/lib/'目录

&emsp;&emsp;如果编译失败，则表示需要下载软件编译后，使用make install即可将头文件和库安装到上述目录中，这样编译链接时就可以查找到，而且一些基础组件大部分项目可以重复使用，另外因为交叉编译会涉及到更多内容的修改，所以本文将以**交叉编译**作为主要的演示脚本应用。<br />
**PS:交叉编译时，一定要重定义安装目录，否则会替换已经安装到系统的库文件，因为平台差异导致无法链接，反而影响系统正常功能。**.

## 交叉编译文件
软件编译方法列表如下.<br />
[zlib软件编译](#下载并交叉编译zlib) <br />
[openssl软件编译](#下载编译openssl) <br />


### 下载并交叉编译zlib

[<-back title](#交叉编译文件)<br />

```shell
base_build=/home/program/install/arm

function build_zlib()
{
    zlib_ver=zlib-1.3
    lib_build=${base_build}/zlib

    #下载zlib, 并解压文件
    if [ ! -d ${zlib_ver}/ ]; then 
        wget http://www.zlib.net/${zlib_ver}.tar.gz
        tar -xvf ${zlib_ver}.tar.gz
    fi
    
    cd ${zlib_ver}/
    make clean

    export CHOST=arm-none-linux-gnueabihf
    ./configure --prefix=${lib_build}
    make -j4 && make install
}
build_zlib
```

## 下载编译openssl

[<-back title](#交叉编译文件)<br />

```shell
base_build=/home/program/install/arm

function build_openssl()
{
    openssl_ver=openssl-3.1.4
    lib_build=${base_build}/openssl
    
    if [ ! -d ${openssl_ver}/ ]; then 
        wget https://www.openssl.org/source/${openssl_ver}.tar.gz
        tar -xvf ${openssl_ver}.tar.gz
    fi

    cd ${openssl_ver}/

    export CC=gcc
    export CXX=g++

    #此步骤等待较久，因为perl要遍历gcc/g++的所有预定义变量并加载，速度比较慢
    ./config --cross-compile-prefix=arm-none-linux-gnueabihf- no-asm --prefix=${lib_build} linux-armv4
    make -j2 && make install
}
build_openssl
```
## 下载编译openssh

[<-back title](#交叉编译文件)<br />

1. openssh的下载和编译
```shell
base_build=/home/program/install/arm

function build_openssh()
{   
    openssh_ver=openssh-9.5p1

    if [ ! -d ${openssh_ver}/ ]; then
        wget https://mirrors.tuna.tsinghua.edu.cn/OpenBSD/OpenSSH/portable/${openssh_ver}.tar.gz
        tar -xvf ${openssh_ver}.tar.gz
    fi

    cd ${openssh_ver}/
    ./configure --host=arm-none-linux-gnueabihf --with-libs --with-zlib=${base_build}/zlib/ \
                --with-ssl-dir=${base_build}/openssl/ --disable-etc-default-login

    make -j2
}
build_openssh
```

编译完成后，目录下的scp sftp ssh sshd ssh-add ssh-agent ssh-keygen ssh-keyscan文件，即是编译后的执行文件.<br />
2.上传文件到嵌入式linux平台，并创建运行环境。<br />
创建以下目录(存在则不需要创建)。<br />

```bash
mkdir /usr/local/bin
mkdir /usr/local/etc
mkdir /usr/libexec
mkdir /var/run
mkdir /var/empty
```
将scp, sftp, ssh, sshd, ssh-agent, ssh-keygen, ssh-keyscan拷贝到/usr/local/bin目录.<br />
将sftp-server, ssh-keysign拷贝到/usr/libexec目录.<br />
将moduli, ssh_config, sshd_config拷贝到/usr/local/etc目录.<br />
在嵌入式平台生成ssh对应密钥.<br />

```bash
cd /usr/bin/etc
/usr/local/bin/ssh-keygen -t rsa -f ssh_host_rsa_key -N ""
/usr/local/bin/ssh-keygen -t dsa -f ssh_host_dsa_key -N ""
/usr/local/bin/ssh-keygen -t ecdsa -f ssh_host_ecdsa_key -N ""
/usr/local/bin/ssh-keygen -t dsa -f ssh_host_ed25519_key -N ""
```
生成完成后，在/etc/passwd中添加sshd用户支持。<br />

```bash
sshd:x:115:65534::/var/run/sshd:/usr/sbin/nologin
```
当然也要和上面桌面端一样，在/usr/local/etc/sshd_config添加支持的加密算法，然后执行。<br />

```bash
/usr/local/bin/sshd
```
另外，将相应的动态库也要复制到嵌入式Linux平台。


## 下载编译mosquitto

## 编译安装gcc

对于linux系统来说，默认是支持gcc/g++的，不过如果想使用最新的C++应用，就需要安装最新的gcc版本，这里采用目前最新的为12.2.0, 进入下载目录，使用wget即可下载.<br/>
**注意:对于linux端，不要用新的gcc库直接替换系统的c-library，很多系统命令如ls，mv...都依赖libc-x.so, 替换后，会导致基本所有命令都没法使用，大概率需要重装(WSL还可以通过windows端替换回来)**
```bash
wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-12.2.0/gcc-12.2.0.tar.gz
tar -xvf gcc-12.2.0.tar.gz
cd gcc-12.2.0
```
理论上要执行./contrib/download_prerequisites直接安装编译环境，不过国内节点速度会很慢，建议先通过vim contrib/download_prerequisites，在起始处有需要的版本,如12.2.0需要如下.<br/>
1. gmp='gmp-6.2.1.tar.bz2'<br/>
2. mpfr='mpfr-4.1.0.tar.bz2'<br/>
3. mpc='mpc-1.2.1.tar.gz'<br/>
4. isl='isl-0.24.tar.bz2'<br/>

&emsp;&emsp;然后就可以使用命令在目录下下载.<br/>
```bash
wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gmp/gmp-6.2.1.tar.bz2
wget https://mirrors.tuna.tsinghua.edu.cn/gnu/mpfr/mpfr-4.1.0.tar.bz2
wget https://mirrors.tuna.tsinghua.edu.cn/gnu/mpc/mpc-1.2.1.tar.gz
wget https://gcc.gnu.org/pub/gcc/infrastructure/isl-0.24.tar.bz2
./contrib/download_prerequisites
./configure --enable-checking=release --enable-languages=c,c++ --disable-multilib --prefix=/home/center/install/gcc12/
make -j4
make install
```
如果编译出现了'stage1-bubble' 清除make distclean, 重新执行make即可 <br/>
编译完成后，需要将编译完成的gcc和g++文件链接到系统目录/usr/bin/下，执行如下 <br/>

```bash
GCC_INSTALL_PATH=/home/center/install/gcc12
echo $GCC_INSTALL_PATH
sudo ln -sf $GCC_INSTALL_PATH/bin/g++ /usr/bin/g++
sudo ln -sf $GCC_INSTALL_PATH/bin/gcc /usr/bin/gcc
sudo ln -sf $GCC_INSTALL_PATH/bin/gcc-ranlib /usr/bin/gcc-ranlib
sudo ln -sf $GCC_INSTALL_PATH/bin//gcc-ar /usr/bin/gcc-ar
sudo ln -sf $GCC_INSTALL_PATH/bin/gcc-nm /usr/bin/gcc-nm
sudo ln -sf $GCC_INSTALL_PATH/bin/gcov /usr/bin/gcov
```
可通过gcc -v或者g++ -v查询版本是否替换成功.<br/>


