<!-- markdownlint-disable MD033 -->
# 嵌入式Linux驱动设计

嵌入式Linux驱动开发的学习过程，其实是理解外部器件，寄存器配置和Linux源码的过程。驱动的学习中，一定要配合芯片和外部器件的手册，进行实际硬件的调试，理解Linux相应源码。回想驱动开发调试经历，可以说是整个学习中最枯燥且繁琐的部分，既不像应用端开发所见即所得，设备树，内核接口也十分抽象；另一个就是不知道如何学习，很多书籍都是讲述要这么设计，却没有指出为什么这么设计。讲述如何处理能够实现对应驱动功能的教程和书籍还有些，但是能够系统并清晰的描述为什么这样能够实现的，我也没看到很好的资料。另外Linux本身的复杂度也越来越高，学习使用的过程中也面临很多困扰，其中最大的感受如下。

1. 功能实现的范式多种多样，设备被应用层访问的接口，可以是设备节点读写接口，设备类下的属性文件等；对于具体硬件的访问可以直接使用物理地址、设备树接口访问，资源接口访问或者通过各类子系统访问等。
2. 学习中接触的驱动代码，和Linux内核中的代码从复杂度上相差很远，看似理解了某个外设和模块，但去看Linux内核中的驱动实现，仍然感觉迷雾重重。

功能范式的多样性可以理解，主要因为Linux内核的迭代原因。早期版本是直接访问硬件，添加驱动，这当然更容易理解，不过这也造成了大量驱动代码冗余。对于兼容大量设备的Linux驱动来，会带来代码量大，配置选项复杂，调试分析困难等问题。为了解决这类问题，并处理如设备热插拔，电源管理等功能，Linux内核在2.6版本以后提出设备驱动模型概念，设备驱动模型将硬件设备归纳、分类、抽象出一套标准的数据结构和接口，我们在开发中关注总线，设备，驱动三个部分，其中总线将设备和驱动绑定。这也是目前的主流推广的模型，无论是去理解Linux内核驱动还是自己实现模块驱动，依托设备驱动模型概念的路线就是最佳实践，按照这种思路，驱动执行具体流程如下所示。

1. 驱动加载到内核的接口
2. 总线实现设备和驱动的匹配(设备注册时查找对应的驱动，驱动注册时查找对应的设备)
3. 驱动执行硬件初始化，实现访问硬件的接口(如中断，数据读写等)。
4. 驱动创建设备，并将设备和硬件访问接口关联，从而支持应用层的访问。

随着内核的迭代，通过子系统实现具体驱动功能，可以更方便驱动的复用。如果改动只涉及接口的调整，通过设备树修改就即可实现，这就提高了开发效率，降低了维护难度。不过当涉及的器件内核不支持或不一致时，需要开发驱动时，反而需要去理解更多的接口，不过学习驱动，肯定不能只限于了解设备树的知识，需要掌握设备驱动模型的对应得接口和用法，这就有了更高得要求。基于现在的驱动模型，内核完整支持一个器件由设备，总线，驱动三部分实现组成。

1. 总线：内核启动后，加载解析设备树，创建支持的总线(如i2c, spi, usb等)。
2. 设备: 解析设备树，在对应总线下创建设备(如ls /sys/bus/i2c/devices列出支持设备)
3. 驱动: 设备工作需求的驱动，实现应用层访问内核数据的接口，以及内核访问外部器件的接口，建立通道，这也是本篇讲解的重点。

- [内核加载接口](#kernel_interface)
- [总线和设备](#bus_driver_modules)

## kernel_interface

驱动开发中，内核提供了一套接口，支持了模块的的加载和移除，另外也支持自定义模块的作者，开源协议和模块描述，模块别名等，这类接口如下所示。

```c
/* 模块加载时函数 */
static void __init ap3216c_module_init
{
}

/* 模块移除时函数 */
static void __exit ap3216c_module_init
{
}

/* 模块加载时访问接口 */
module_init(ap3216c_module_init);

/* 模块移除时访问接口 */
module_exit(ap3216c_module_exit);

/* 模块作者 */
MODULE_AUTHOR("jason");

/* 模块license */
MODULE_LICENSE("GPL v2");

/* 模块描述 */
MODULE_DESCRIPTION("ap3216 driver");

/* 模块别名 */
MODULE_ALIAS("ap3216 drive");
```

上面是典型的驱动模块的接口，ap3216c_module_init在驱动模块加载时调用，ap3216c_module_init在模块移除时调用。 实际开发中可以将驱动添加到内核对应的Driver目录下，可以参考[menuconfig说明](./ch02-02.menuconfig.md)的说明。如果以模块的形式存在，则内核支持两类命令管理模块的加载和移除。

1. insmod [mod].ko/rmmod [mod].ko，加载和卸载模块，需要模块的完整路径和名称(支持单模块组成的驱动)。
2. modprobe, 其中modprobe [mod]加载模块，modprobe -r [mod]卸载对应模块, 执行依赖"/lib/modules/(uname -r)"路径下的modules.dep内保存的驱动依赖关系，对于多模块组成的驱动，只能使用modprobe管理。
3. depmod，遍历/lib/modules/(uname -r)路径，生成依赖关系，放置在/lib/modules/(uname -r)路径下。

## bus_driver_modules

驱动模块加载后，就通过总线实现设备和驱动的匹配, 根据处理

1. 驱动的加载过程中，总线检索设备树匹配对应的设备，完成设备和驱动的关联，这部分主要在modprobe和insmod时完成。
2. 设备加载时(主要时支持热插拔的设备)，总线则检索对应的驱动，在系统中添加对应设备。

对于我们大部分遇到的驱动，除支持热插拔的USB，HDMI，SATA等，大部分驱动都是不支持热插拔的，因此我们面对的都是情况1，存在设备的情况下，进行驱动的加载。那么设备是什么时候创建的了，总线如何通过如何进行设备和驱动得匹配的，这里先展示一张硬件拓扑，对于理解这个问题很重要。

![image](image/hardwarePlatform.PNG)

从上面拓扑可以看到，Linux将硬件抽象成Bus，Class和Device概念。在驱动开发中，如果外部器件挂在指定的总线上，可以直接使用对应的总线匹配接口进行驱动的初始化，以i2c总线上设备为例。

```c
//匹配设备的代码
//总线上匹配的设备
static const struct of_device_id ap3216_of_match[] = {
    { .compatible = "rmk,ap3216" },
    { /* Sentinel */ }
};

static struct i2c_driver ap3216_driver = {
    .probe = i2c_probe,
    .remove = i2c_remove,
    .driver = {
        .owner = THIS_MODULE,
        .name = "ap3216",
        .of_match_table = ap3216_of_match, 
    },
};

static int __init ap3216_module_init(void)
{
    //总线上加载驱动
    return i2c_add_driver(&ap3216_driver);
}

static void __exit ap3216_module_exit(void)
{
    //总线上移除驱动
    return i2c_del_driver(&ap3216_driver);
}

//生成设备树的设备代码
&i2c1 {
    clock-frequency = <100000>;
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_i2c1>;
    status = "okay";
   
    ap3216@1e {
        compatible = "rmk,ap3216";  //用于设备树匹配的属性
        reg = <0x1e>;
    };
};
```

可以看到，在驱动的入口，就通过compatible属性内容，将设备和驱动通过i2c总线进行了关联管理。

Bus是ARM Core和一个和多个外设之间进行信息交互的通道，对于实际存在的物理硬件总线如I2C, SPI, HID, SDIO等，外部挂载多个设备，比较好理解。不过还有一类设备，如gpio，pwm，timer，rng，crypto以及i2c, spi, usb设备的控制器，硬件上和Core相连，不属于传统意义的总线连接。Linux内核为了方便管理这一类设备，定义了虚拟总线(platform bus)，这些非传统意义的设备都由虚拟总线统一管理。这样所有的设备都可通过简化成由总线，设备和驱动组成统一设备模型。

总线以及总线支持的设备最终也显示到系统目录中，可以通过系统启动后通过如下命令查看。

```shell
#查看系统支持的总线
ls /sys/bus

#查看总线已经注册的设备，以i2c为例
ls /sys/bus/i2c/devices

0-001e  1-0014  i2c-0   i2c-1
#0-001e 表示为i2c-0中地址为0x1e的i2c设备
#1-0014 表示为i2c-1中地址为0x14的i2c设备
#也可以进入对应目录，进一步查看名称和属性
```

通过访问这个目录，可以用来判断设备树是否符合总线的需求，能够被创建，这在分析驱动未加载问题时，十分重要。

devices是由系统启动时注册加载的硬件信息，是对内部外设和外部器件的信息抽象，在最初的统一设备模型中，设备也由专门的代码实现。在代码中定义一系列的关于设备信息的表格，通过id_table匹配成功后，driver既可以访问这些硬件信息，实现具体的驱动。较新的Linux将设备进一步抽象成设备树，在启动时解析生成设备，这就简化了对完整驱动的开发。

Class则是在Linux设备模型中类似面向对象程序设计中的类，它主要是集合具有相似功能或属性的设备，这样就可以抽象出一套可以在多个设备之间共用的数据结构和接口函数。因而从属于相同Class的设备的驱动程序，可以直接从Class中继承即可，关于支持的类，可以通过如下命令查看。

```shell
#查看系统支持的类
ls /sys/class
```

Driver则是驱动设备运行的程序，提供硬件和上层应用访问的通道，从而实现对于底层硬件驱动的访问。

```shell
#查看当前的设备号
cat /proc/devices
```

## driver_modules

|  模块 | 功能说明 |
| --- | --- |
| gpio | 1.pinctrl子系统<br/> 2. input输入子系统 |
| i2c | i2c子系统，regmap子系统 |
| spi | spi子系统，regmap子系统 |
| rtc | rtc子系统 |
| adc | iio子系统 |
| watchdog | 窗口看门狗 |
| pwm | pwm子系统 |
| thermal | 1.温控thermal子系统<br /> 2.cool设备 |
| fb  | fb图形子系统 |
| fb drm | fb drm子系统 |
| block | 块设备 |
| can | 网络设备 |
| fec | 网络设备 |
| wifi | 网络设备 |
| usb | usb设备 |
| pci | pci接口 |

## next_chapter

[返回目录](./SUMMARY.md)

直接开始下一节说明: [设备树语法说明](./ch03-01.device_tree.md)
