# driver_design

嵌入式Linux驱动开发的学习过程，其实是理解外部器件，寄存器配置和逐渐理解和掌握Linux源码的过程；驱动的学习中，一定要配合芯片和外部器件的手册，进行实际硬件的调试，理解Linux相应模块的源码，才能算真正掌握相应的模块。回想产品硬件驱动开发调试经历，驱动开发是整个学习中最枯燥且繁琐的部分，既不像应用端开发所见即所得，设备树，内核接口也十分抽象。讲述如何如何处理能够实现对应驱动功能的教程和书籍很多，但是能够系统并清晰的描述为什么这样能够实现的，我目前还没有找到。另外Linux本身的复杂度也越来越高，学习使用的过程中也面临很多困扰，其中最大的感受如下.

1. 功能实现的范式多种多样，例如设备的创建可以使用字符设备接口，杂项设备接口，自行申请设备号创建等；对于具体硬件的访问可以直接使用物理地址，基于设备树的各类子系统访问等，包括硬件初始化都可以使用不同的接口实现。
2. 学习中接触的驱动代码，和Linux内核中的代码从复杂度上相差很远，即使理解了某个外设和模块，去看内核内部的驱动实现，仍然十分困难。

功能范式的多样性可以理解，主要因为Linux内核的迭代原因，早期版本是直接访问硬件，添加驱动，这当然更容易理解，不过这也造成了大量驱动代码冗余，如果开发大量设备驱动，也面临着配置选项复杂，调试分析困难，为了解决这类问题，并处理如设备热插拔，电源管理等功能，Linux内核在2.6版本以后提出设备驱动模型概念，设备驱动模型将硬件设备归纳、分类、抽象出一套标准的数据结构和接口，我们在开发中关注总线，设备，驱动三个部分，其中总线将设备和驱动绑定。这也是目前的主流，无论是去理解Linux内核驱动还是自己实现模块驱动，依托设备驱动模型概念的路线就是最佳实践，驱动执行具体流程如下。

1. 驱动加载到内核的接口
2. 总线实现设备和驱动的匹配(设备注册时查找对应的驱动，驱动注册时查找对应的设备)
3. 驱动执行硬件初始化，提供硬件访问接口。
4. 驱动创建设备，并将设备和硬件访问接口关联，从而支持应用层的访问。

随着内核的迭代，虽然可以通过子系统实现具体驱动功能，可以更方便驱动的复用，如果改动只涉及接口的调整，通过设备树修改就能解决，那么这类改动是提高开发效率，降低开发难度的。不过当涉及的器件内核不支持或者不一致时，需要开发驱动时，反而需要去理解更多的接口，不过学习驱动，肯定不能只限于了解设备树的知识，需要掌握设备驱动模型的对应得接口和用法，这就有了更高得要求。

- [内核加载接口](#kernel_interface)
- [总线和设备](#bus_and_device)

## kernel_interface

驱动开发中，内核提供了一套接口，支持了模块的的加载和移除，另外也支持自定义模块的作者，开源协议和模块描述，模块别名等，这类接口如下所示。

```c
/* 模块加载时函数 */
static void __init ap3216c_module_init
{
}

/* 模块移除时函数 */
static void __exit ap3216c_module_init
{
}

/* 模块加载时访问接口 */
module_init(ap3216c_module_init);

/* 模块移除时访问接口 */
module_exit(ap3216c_module_exit);

/* 模块作者 */
MODULE_AUTHOR("jason");

/* 模块license */
MODULE_LICENSE("GPL v2");

/* 模块描述 */
MODULE_DESCRIPTION("ap3216 driver");

/* 模块别名 */
MODULE_ALIAS("ap3216 drive");
```

上面是典型的驱动模块的接口，ap3216c_module_init在驱动模块加载时调用，ap3216c_module_init在模块移除时调用. 在Linux系统中，就可以通过insmod或modprobe进行加载驱动，通过modprobe -r移除驱动。

## bus_and_device

驱动模块加载后，就通过总线实现设备和驱动的匹配, 根据处理

1. 驱动的加载过程中，总线检索设备树匹配对应的设备，完成设备和驱动的关联，这部分主要在modprobe和insmod时完成。
2. 设备加载时(主要时支持热插拔的设备)，总线则检索对应的驱动，在系统中添加对应设备。

对于我们大部分遇到的驱动，除支持热插拔的USB，HDMI，SATA等，大部分驱动都是不支持热插拔的，因此我们面对的都是情况1，存在设备的情况下，进行驱动的加载。那么设备是什么时候创建的了，总线如何通过如何进行设备和驱动得匹配的，这里先展示一张硬件拓扑，对于理解这个问题很重要。

![image](image/hardwarePlatform.PNG)

从上面拓扑可以看到，Linux将硬件抽象成Bus，Class和Device概念。

Bus是ARM Core和一个和多个外设之间进行信息交互的通道，对于实际存在的物理硬件总线如I2C, SPI, HID, SDIO等，外部挂载多个设备，比较好理解，不过还有一类设备，如gpio，pwm，timer，rng，crypto以及各设备的控制器，直接和内核连接，不属于传统意义的总线连接。不过Linux内核为了方便管理，定义了虚拟总线(platform bus)用于管理这类设备，这样所有的设备的设备都可以通过上面提到的统一设备模型进行管理。另外总线以及总线支持的设备最终也显示到系统目录中，可以通过系统启动后通过如下命令查看。

```shell
#查看系统支持的总线
ls /sys/bus

#查看总线已经注册的设备，以i2c为例
ls /sys/bus/i2c/devices

#0-001e  1-0014  i2c-0   i2c-1
#0-001e 表示为i2c-0中地址为0x1e的i2c设备
#1-0014 表示为i2c-1中地址为0x14的i2c设备
#也可以进入对应目录，进一步查看名称和属性
```

通过访问这个目录，可以用来判断设备树是否符合总线的需求，能够被创建，这在分析驱动问题时，十分重要。

Class则是在Linux设备模型中类似面向对象程序设计中的类，它主要是集合具有相似功能或属性的设备，这样就可以抽象出一套可以在多个设备之间共用的数据结构和接口函数。因而从属于相同Class的设备的驱动程序，可以直接从Class中继承即可，关于支持的类，可以通过如下命令查看。

```shell
#查看系统支持的类
ls /sys/class

#查看类已经注册的设备
ls /sys/class/input/
```

Devices则是系统中的所有的硬件设备，描述它的名字、属性、从属的Bus、从属的Class等信息。

## next_chapter

[返回目录](./SUMMARY.md)

直接开始下一节说明: [ch03-01.设备树说明](./ch03-01.device_tree.md)
