# embed linux driver design

对于嵌入式Linux驱动开发，有各种各样的教程和书籍进行说明，如韦东山，正点原子，飞凌嵌入式的相关驱动教程都有丰富说明，不过回想一路的产品硬件驱动开发调试经历，驱动开发是整个学习中最枯燥且繁琐的部分，既不像应用端开发所见即所得，设备树，内核接口往往还十分抽象，即使对硬件有一定掌握，实现驱动也并不简单。另外重要的是，Linux内核的迭代原因，对于同一种硬件，往往支持不同的接口去访问，很多时候会因为混用接口，虽然最终实现了功能，但其实并不是好的实践，一般来说，被合并到主干的驱动代码，基本是官方的实现，所以最好的源码学习一定是Linux内核中的驱动文件, 不过这种代码往往对于入门者理解十分困难，这里就总结一套我去理解驱动的思路，并以这个思路去讲解驱动开发涉及的知识点。

驱动是集成在内核中，用于连接硬件外设和应用的功能模块。主要功能如下.

1. 实现硬件配置(寄存器操作), 读，写或控制等操作；
2. 提供Linux内核加载，移除和访问的读写支持；
3. 创建应用访问的相关文件和并关联接口。

当然Linux内核也会支持一部分内核接口，实现同步/异步，并发/并行，互斥等逻辑，这是写好稳定可靠内核驱动的重要部分之一。驱动工作的流程大致为:**应用访问设备文件, 通过内核管理的关联结构执行对于读写，控制接口，最后访问到具体硬件操作**，实现对于外设(包含gpio, adc, cmos或触摸，can，rs232，rs485等外设)的访问功能.

嵌入式Linux驱动的学习也可以是循序渐进的过程，不过为了更好的了解相关说明，也需要一定的基础，可以起到事半功倍的效果.

- 对于SOC的硬件有一定了解，特别是理解寄存器相关的配置
- 一定的嵌入式Linux C语言能力

下面按照章节去讲解上述说明。

- [linux内核的加载，移除和说明接口](#kernel_interface)
- [linux硬件初始化和访问接口](#hardware_interface)

## kernel_interface

对于Linux驱动开发，肯定是要先易后难，内核提供了一套接口，支持了模块的的加载和移除，另外也支持自定义模块的作者，开源协议和模块描述，模块别名等，这类接口如下所示。

```c
//module加载时函数
static void __init [device]_init
{
}

//module移除时函数
static void __exit [device]_exit
{
}

module_init([device]_init);
module_exit([device]_exit);
MODULE_LICENSE("GPL");
MODUEL_AUTHOR("ck");
```

上面是典型的Linux模块的接口，[device]_init可以在模块加载时被调用，[deivce]_exit在模块移除时调用.<br />
到这一步，驱动中用于内核访问的接口就说明完毕了，是不是并不困难，这些只是开胃菜，下面开始最重要的部分，也是Linux驱动中复杂的原因之一。<br />

## hardware_interface

对于嵌入式Linux的中硬件部分的配置和操作，是跟随着内核的迭代，也在逐渐的更加抽象，而作为开发者，也要逐渐适应这种改变。从最初的直接寄存器操作，到目前设备树的处理后进行开发成为主流，理论上两类API最终都是转换成硬件的操作，但其实从思路和接口上都差别很大，以我的体验来说，学习基础的寄存器操作，对于设备树的开发学习基本没啥帮助，所以还是直接设备树版本的驱动开发学习反而更加省时省力。

## device_tree

## deivce_create_interface
