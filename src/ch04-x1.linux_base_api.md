# Linux基础应用层接口

对于Linux系统，为上层应用提供一系列升级

Linux API相关接口，内容参考如下文档。

- 《UNIX环境高级编程》
- 《UNIX网络编程 卷2：进程间通信》

接口目录如下。

- [dir_api](#dir_api)
- [file_io](#file_io)
- [process_api](#process_api)
- [system_api](#system_api)
- [thread_api](#thread_api)
- [env_api](#env_api)
- [time_api](#time_api)

## dir_api

用于管理目录的api接口：opendir，readdir，closedir，mkdir。

```c
//目录相关的头文件
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>

// 获取目录的管理指针
// @__name: 目录访问路径
// @return: 管理目录的资源
DIR *opendir (const char *__name);

// 读取目录的具体信息
// @__dirp: 已经请求的目录指针
// @return: 目录的具体信息指针
struct dirent *readdir (DIR *__dirp);

// 关闭获得的目录指针
// @__dirp: 已经请求的目录指针
// @return: 0表示关闭成功，负值返回对应错误码
int closedir (DIR *__dirp);

// 创建目录
// @__path: 目录访问路径
// @__mode: 创建目录的权限, 可以是0644，0777
// @return: 0表示创建成功，负值返回对应错误码
int mkdir (const char *__path, __mode_t __mode);

// 删除目录
// @pathname: 指向要删除的目录的路径名的指针
// @return: 0表示删除成功，负值返回对应错误码
int rmdir(const char *pathname);
```

## file_io

用于管理文件的api接口：open，read，write，close，ioctl，lseek，stat, fstat。

```c
//文件处理的相关头文件
#include <fcntl.h>
#include <unistd>

// 打开文件，并返回一个文件描述符
// @pathname: 文件路径
// @flags: 文件打开的模式，常见的值有O_RDONLY(只读), O_WRONLY(只写), O_RDWR(可读写)，O_CREAT(创建文件), O_APPEND(追加)等
// @mode: 文件权限
// @return: 文件描述符
int open(const char *pathname, int flags, mode_t mode);

// 从文件描述符中读取数据
// @fd: 文件描述符
// @__buf: 读取的数据存放的缓冲区
// @__nbytes: 读取的数据字节数
// @return: 实际读取的字节数
ssize_t read(int __fd, void *__buf, size_t __nbytes);

// 向文件描述符中写入数据 
// @fd: 文件描述符
// @buf: 写入的数据缓冲区   
// @count: 写入的数据字节数
// @return: 实际写入的字节数
ssize_t write(int fd, const void *buf, size_t count);

// 关闭文件描述符
// @fd: 文件描述符
// @return: 0表示关闭成功，负值返回对应错误码
int close(int fd);

// 移动文件指针偏移地址,和read配合使用从指定起始地址读取数据
// @fd: 文件描述符
// @request: 设备特定的请求码
// @...: 可变参数
// @return: 0表示成功，负值表示失败
int ioctl(int fd, unsigned long int request, ...);

// 移动文件指针偏移地址,和read配合使用从指定起始地址读取数据
// @fd: 文件描述符
// @offset: 偏移量
// @whence: 偏移的起始位置
// @return: 0表示成功，负值表示失败
int lseek(int fd, off_t offset, int whence);

// 获取文件的状态信息
// @path: 文件路径
// @buf: 文件状态信息的缓冲区
// @return: 0表示成功，负值表示失败
int stat(const char *path, struct stat *buf);

// 获取文件的状态信息
// @fd: 文件描述符
// @buf: 文件状态信息的缓冲区
// @return: 0表示成功，负值表示失败
int fstat(int fd, struct stat *buf);
```

## process_api

用于管理进程的api接口：fork，getpid，getppid，getuid，perror。

```c
//系统处理的相关头文件
#include <sys/types.h>
#include <unistd.h>

// 创建一个新的进程，新进程是调用进程的副本
// @return: 进程得pid，0表示子进程，正值表示父进程，负值表示fork失败
__pid_t fork(void);

// 获得当前进程的pid值
// @return: 进程得pid
__pid_t getpid(void);

// 获得当前进程的父进程pid值
// @return: 进程得pid
__pid_t getppid(void);

// 获得当前进程的uid值
// @return: 进程得uid
__uid_t getuid (void);
```

## system_api

用于系统管理的api接口：perror, system, getopt，chmod，chown, signal。

```c
//系统处理的相关头文件
#include <stdio.h>
#include <unistd.h>

// 打印错误信息
// @s: 错误信息
void perror(const char *s);

//执行调用其它程序或者指令
// @__command: 指令
// @return: 0表示成功，负值表示失败
int system (const char *__command);

// 解析命令行参数
// @argc: 参数个数
// @argv: 参数数组
// @optstring: 选项字符串
// @return: 解析到的选项字符
int getopt(int argc, char *const argv[], const char *optstring);

// 改变文件的权限
// @path: 文件路径
// @mode: 文件权限
// @return: 0表示成功，负值表示失败
int chmod (const char *__path, __mode_t __mode);

// 改变文件的所有者
// @path: 文件路径
// @owner: 文件所有者
// @group: 文件所属组
// @return: 0表示成功，负值表示失败
int chown (const char *__path, __uid_t __owner, __gid_t __group);

// 注册信号处理函数
// @signum: 处理的信号，常见SIGINT 表示中断信号（通常由用户按下 Ctrl+C 产生），SIGTERM 表示终止信号
// @handler: 信号处理函数
// @return: 0表示成功，负值表示失败
int signal(int signum, void (*handler)(int));
```

## thread_api

用于线程创建的和处理的api接口：pthread_create，pthread_join，pthread_exit，pthread_detach，pthread_mutex_lock，pthread_mutex_unlock，pthread_spin_lock，pthread_spin_unlock, pthread_spin_trylock。

```c
//线程相关的头文件
#include <pthread.h>

//创建线程
// @tid: 线程id
// @attr: 线程属性
// @start_routine: 线程函数
// @arg: 线程函数的参数
// @return: 0表示成功，负值表示失败
int pthread_create(pthread_t *tid, const pthread_arrt_t* attr, void*(*start_routine)(void *), void* arg);  

//等待线程结束
// @thread: 线程id
// @retval: 线程返回值
// @return: 0表示成功，负值表示失败
int pthread_join(pthread_t thread, void **retval);

//线程退出
// @retval: 线程返回值
void pthread_exit(void * retval);

//分离线程，被分离的线程结束时自动释放资源
// @tid: 线程id
// @return: 0表示成功，负值表示失败
int pthread_detach(pthread_t tid);

//互斥锁
pthread_mutex_t m_lock;
pthread_mutexattr_t attr;

// 互斥锁初始化
// @mutex: 互斥锁
// @attr: 互斥锁属性
// @return: 0表示成功，负值表示失败
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);

// 互斥锁属性初始化
// @attr: 互斥锁属性
// @return: 0表示成功，负值表示失败
int pthread_mutexattr_init(pthread_mutexattr_t *attr);

// 互斥锁属性设置
// @attr: 互斥锁属性
// @type: 互斥锁类型，常见的PTHREAD_MUTEX_NORMAL(不带死锁检测)，PTHREAD_MUTEX_ERRORCHECK(带死锁检测)，PTHREAD_MUTEX_RECURSIVE(递归互斥锁)，PTHREAD_MUTEX_DEFAULT(默认属性)
// @return: 0表示成功，负值表示失败
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);

// 互斥锁销毁
// @mutex: 互斥锁
// @return: 0表示成功，负值表示失败
int pthread_mutex_destroy(pthread_mutex_t *mutex);

// 互斥锁加锁
// @mutex: 互斥锁
// @return: 0表示成功，负值表示失败
int pthread_mutex_lock(pthread_mutex_t *mutex);

// 互斥锁解锁
// @mutex: 互斥锁
// @return: 0表示成功，负值表示失败
int pthread_mutex_unlock(pthread_mutex_t *mutex);

//自旋锁
pthread_spinlock_t m_spinlock;

// 自旋锁初始化
//  @lock: 自旋锁
//  @pshared: 0表示线程间共享，非0表示进程间共享
//  @return: 0表示成功，负值表示失败
int pthread_spin_init(pthread_spinlock_t *lock, int pshared);

// 自旋锁销毁
//  @lock: 自旋锁
//  @return: 0表示成功，负值表示失败
int pthread_spin_destroy(pthread_spinlock_t *lock);

// 自旋锁加锁
//  @lock: 自旋锁
//  @return: 0表示成功，负值表示失败
int pthread_spin_lock(pthread_spinlock_t *lock);

// 自旋锁解锁
//  @lock: 自旋锁
//  @return: 0表示成功，负值表示失败
int pthread_spin_unlock(pthread_spinlock_t *lock);

// 自旋锁尝试加锁
//  @lock: 自旋锁
//  @return: 0表示成功，负值表示失败
int pthread_spin_trylock(pthread_spinlock_t *lock);
```  

## env_api

用于系统环境管理的api接口：getenv，setenv，unsetenv，putenv。

```cpp
// 系统环境相关的头文件
#include <stdlib.h>

// 获取系统环境变量
// @name: 环境变量名称
// @return: 环境变量的值
char *getenv(const char *name);

// 添加和修改环境变量
// @name: 环境变量名称
// @value: 环境变量的值
// @rewrite: 0表示不覆盖，非0表示覆盖
// @return: 0表示成功，负值表示失败
int setenv(const char *name, const char *value, int rewrite);

// 删除环境变量
// @name: 环境变量名称
// @return: 0表示成功，负值表示失败
int unsetenv(const char *name);

//写入环境变量，覆盖或者添加, 和setenv功能类似，实现上格式为name=string
// @str: 指向一个字符串的指针，该字符串的格式为 "name=value"，其中 "name" 是环境变量的名称，"value" 是环境变量的值
// @return: 0表示成功，负值表示失败
int putenv(char *str); 
```

## time_api

用于系统时间获取和处理的相关API接口：time，gmtime，localtime，asctime，ctime，mktime，setitimer。

```cpp
// 获取系统的日历时间，以1970-1-1, 00:00:00开始计算的seconds值
// @timer: 一个指向 time_t 类型的指针，用于存储返回的日历时间。如果 timer 为 NULL，则函数只返回当前的日历时间，而不存储它
// @return: 如果__timer不为NULL，存储在timer指向位置，并返回时间值，timer为NULL，返回时间值，发生错误，函数返回-1
time_t time (time_t *__timer);

//根据日历时间获取GMT时间的函数
// @timer: 一个指向 time_t 类型的指针
// @return: 返回一个指向 struct tm 类型的指针，该指针指向的结构体包含了 GMT 时间的各个字段
// struct tm格式
struct tm {
    int tm_sec;   // 秒，取值范围 0-59
    int tm_min;   // 分，取值范围 0-59
    int tm_hour;  // 时，取值范围 0-23
    int tm_mday;  // 日，取值范围 1-31
    int tm_mon;   // 月，取值范围 0-11（0 表示一月）
    int tm_year;  // 年，从1900开始计算
    int tm_wday;  // 星期，取值范围 0-6（0 表示星期日）
    int tm_yday;  // 一年中的第几天，取值范围 0-365
    int tm_isdst; // 夏令时标志，正数表示夏令时，0表示非夏令时，负数表示信息不可用
};
struct tm *gmtime (const time_t *__timer);

//根据日历时间获取GMT时间的函数(使用用户缓冲区而不是内部缓冲区)
// @timer: 一个指向 time_t 类型的指针
// @tp: 一个指向 struct tm 类型的指针
// @return: 返回一个指向 struct tm 类型的指针，该指针指向的结构体包含了 GMT 时间的各个字段
struct tm *gmtime_r (const time_t *__restrict __timer,  struct tm *__restrict __tp)

//根据日历时间获取本地时间的函数(根据/etc/localtime文件)
// @timer: 一个指向 time_t 类型的指针
// @return: 返回一个指向 struct tm 类型的指针，该指针指向的结构体包含了本地时间的各个字段
struct tm *localtime (const time_t *__timer);

//根据日历时间获取本地时间的函数(使用用户缓冲区而不是内部缓冲区)
// @timer: 一个指向 time_t 类型的指针
// @tp: 一个指向 struct tm 类型的指针
// @return: 返回一个指向 struct tm 类型的指针，该指针指向的结构体包含了本地时间的各个字段
struct tm *localtime_r (const time_t *__restrict __timer, struct tm *__restrict __tp)

//根据tm时间结构生成字符串
// @tp: 一个指向 struct tm 类型的指针
// @return: 返回一个指向字符串的指针，该字符串包含了 tm 时间结构的各个字段的字符串表示
char *asctime (const struct tm *__tp);

//根据tm时间结构生成字符串(使用用户缓冲区而不是内部缓冲区)
// @tp: 一个指向 struct tm 类型的指针
// @buf: 一个指向字符数组的指针，用于存储生成的字符串
// @return: 返回一个指向字符数组的指针，该指针指向的字符串包含了 tm 时间结构的各个字段的字符串表示
char *asctime_r (const struct tm *__restrict __tp, char *__restrict __buf);

//根据日历时间生成时间字符串
// @timer: 一个指向 time_t 类型的指针
// @return: 返回一个指向字符串的指针，该字符串包含了日历时间的各个字段的字符串表示
char *ctime (const time_t *__timer);

//根据日历时间生成时间字符串(使用用户缓冲区而不是内部缓冲区)
// @timer: 一个指向 time_t 类型的指针
// @buf: 一个指向字符数组的指针，用于存储生成的字符串
char *ctime_r (const time_t *__restrict __timer, char *__restrict __buf);

//将带时区的时间转换成秒值
// @tp: 一个指向 struct tm 类型的指针
// @return: 返回一个 time_t 类型的值，表示日历时间
time_t mktime (struct tm *__tp);

//创建软件定时器的函数，超时后会触发SIGALRM信号，使用signal函数捕捉该信号
// @which: 定时器类型，ITIMER_REAL(实时定时器)，ITIMER_VIRTUAL(虚拟定时器)，ITIMER_PROF(性能定时器)
// @value: 一个指向 struct itimerval 类型的指针，该指针指向的结构体包含了定时器的初始值和间隔值
// @ovalue: 一个指向 struct itimerval 类型的指针，该指针指向的结构体包含了定时器的初始值和间隔值
// @return: 0表示成功，负值表示失败
struct itimerval {
    struct timeval it_interval; // 定时器的间隔值
    struct timeval it_value;    // 定时器的初始值
};
int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue));
```

## next_chapter

[返回目录](../README.md)

直接开始下一节说明: [Linux复杂应用层接口](./ch04-x2.linux_complex_api.md)
