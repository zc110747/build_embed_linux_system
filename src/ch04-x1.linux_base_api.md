# Linux基础应用层接口

对于Linux系统，为上层应用提供一系列升级

Linux API相关接口，内容参考如下文档。

- 《UNIX环境高级编程》
- 《UNIX网络编程 卷2：进程间通信》

接口目录如下。

- [dir_api](#dir_api)
- [file_io](#file_io)
- [process_api](#process_api)
- [pthread](pthread)
- [system_env](system_env)

## dir_api

用于管理目录的api接口：opendir，readdir，closedir，mkdir。

```c
//目录相关的头文件
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>

// 获取目录的管理指针
// @__name: 目录访问路径
// @return: 管理目录的资源
DIR *opendir (const char *__name);

// 读取目录的具体信息
// @__dirp: 已经请求的目录指针
// @return: 目录的具体信息指针
struct dirent *readdir (DIR *__dirp);

// 关闭获得的目录指针
// @__dirp: 已经请求的目录指针
// @return: 0表示关闭成功，负值返回对应错误码
int closedir (DIR *__dirp);

// 创建目录
// @__path: 目录访问路径
// @__mode: 创建目录的权限, 可以是0644，0777
// @return: 0表示创建成功，负值返回对应错误码
int mkdir (const char *__path, __mode_t __mode);

// 删除目录
// @pathname: 指向要删除的目录的路径名的指针
// @return: 0表示删除成功，负值返回对应错误码
int rmdir(const char *pathname);
```

## file_io

用于管理文件的api接口：open，read，write，close，ioctl，lseek，stat, fstat。

```c
//文件处理的相关头文件
#include <fcntl.h>
#include <unistd>

// 打开文件，并返回一个文件描述符
// @pathname: 文件路径
// @flags: 文件打开的模式，常见的值有O_RDONLY(只读), O_WRONLY(只写), O_RDWR(可读写)，O_CREAT(创建文件), O_APPEND(追加)等
// @mode: 文件权限
// @return: 文件描述符
int open(const char *pathname, int flags, mode_t mode);

// 从文件描述符中读取数据
// @fd: 文件描述符
// @__buf: 读取的数据存放的缓冲区
// @__nbytes: 读取的数据字节数
// @return: 实际读取的字节数
ssize_t read(int __fd, void *__buf, size_t __nbytes);

// 向文件描述符中写入数据 
// @fd: 文件描述符
// @buf: 写入的数据缓冲区   
// @count: 写入的数据字节数
// @return: 实际写入的字节数
ssize_t write(int fd, const void *buf, size_t count);

// 关闭文件描述符
// @fd: 文件描述符
// @return: 0表示关闭成功，负值返回对应错误码
int close(int fd);

// 移动文件指针偏移地址,和read配合使用从指定起始地址读取数据
// @fd: 文件描述符
// @request: 设备特定的请求码
// @...: 可变参数
// @return: 0表示成功，负值表示失败
int ioctl(int fd, unsigned long int request, ...);

// 移动文件指针偏移地址,和read配合使用从指定起始地址读取数据
// @fd: 文件描述符
// @offset: 偏移量
// @whence: 偏移的起始位置
// @return: 0表示成功，负值表示失败
int lseek(int fd, off_t offset, int whence);

// 获取文件的状态信息
// @path: 文件路径
// @buf: 文件状态信息的缓冲区
// @return: 0表示成功，负值表示失败
int stat(const char *path, struct stat *buf);

// 获取文件的状态信息
// @fd: 文件描述符
// @buf: 文件状态信息的缓冲区
// @return: 0表示成功，负值表示失败
int fstat(int fd, struct stat *buf);
```

## process_api

用于管理进程的api接口：fork，getpid，getppid，getuid，perror。

```c
//系统处理的相关头文件
#include <sys/types.h>
#include <unistd.h>

// 创建一个新的进程，新进程是调用进程的副本
// @return: 进程得pid，0表示子进程，正值表示父进程，负值表示fork失败
__pid_t fork(void);

// 获得当前进程的pid值
// @return: 进程得pid
__pid_t getpid(void);

// 获得当前进程的父进程pid值
// @return: 进程得pid
__pid_t getppid(void);

// 获得当前进程的uid值
// @return: 进程得uid
__uid_t getuid (void);
```

## system_api

用于系统管理的api接口：perror, system, getopt，chmod，chown, signal。

```c
//系统处理的相关头文件
#include <stdio.h>
#include <unistd.h>

// 打印错误信息
// @s: 错误信息
void perror(const char *s);

//执行调用其它程序或者指令
// @__command: 指令
// @return: 0表示成功，负值表示失败
int system (const char *__command);

// 解析命令行参数
// @argc: 参数个数
// @argv: 参数数组
// @optstring: 选项字符串
// @return: 解析到的选项字符
int getopt(int argc, char *const argv[], const char *optstring);

// 改变文件的权限
// @path: 文件路径
// @mode: 文件权限
// @return: 0表示成功，负值表示失败
int chmod (const char *__path, __mode_t __mode);

// 改变文件的所有者
// @path: 文件路径
// @owner: 文件所有者
// @group: 文件所属组
// @return: 0表示成功，负值表示失败
int chown (const char *__path, __uid_t __owner, __gid_t __group);

// 注册信号处理函数
// @signum: 处理的信号，常见SIGINT 表示中断信号（通常由用户按下 Ctrl+C 产生），SIGTERM 表示终止信号
// @handler: 信号处理函数
// @return: 0表示成功，负值表示失败
int signal(int signum, void (*handler)(int));
```

## pthread

```c
//线程的创建  
int pthread_create(pthread_t *tid, const pthread_arrt_t* attr,  
                    void*(*start_routine)(void *), void* arg);  
//等待线程的结束,非分离的线程在结束后只有执行join才会释放全部资源  
int pthread_join(pthread_t thread, void **retval);
//线程离开时的返回值(必须为malloc或者全局变量)  
void pthread_exit(void * retval);
//分离线程,被分离的线程在结束后自动释放所有资源  
int pthread_detach(pthread_t tid);
//多线程的交互--互斥量和自旋锁  
//互斥量 
pthread_mutex_t m_lock;  
pthread_mutex_destroy(&m_lock);  
thread_mutex_lock(&m_lock)  
pthread_mutex_unlock(&m_lock);  
//自旋锁  
pthread_spinlock_t m_spinlock;  
pthread_spin_destroy(&m_spinlock);  
pthread_spin_lock(&m_spinlock);  
pthread_spin_trylock(&m_spinlock);  
pthread_spin_unlock(&m_spinlock);  
```  

## system_env

```cpp
//获取系统环境变量
char *getenv(const char *name);
//添加和修改环境变量
int setenv(const char *name, const char *value, int rewrite);
//删除环境变量
int unsetenv(const char *name);
//写入环境变量，覆盖或者添加, 和setenv功能类似，实现上格式为name=string
char *putenv(char *str); 
//执行调用其它程序或者指令
int system (const char *__command);
```

## time

```cpp
//获取系统的日历时间，以1970-1-1, 00:00:00开始
time_t time (time_t *__timer);
//根据日历时间获取GMT时间的函数
struct tm *gmtime (const time_t *__timer);
struct tm *gmtime_r (const time_t *__restrict __timer,  struct tm *__restrict __tp)
//获取本地时间的函数
struct tm *localtime (const time_t *__timer);
struct tm *localtime_r (const time_t *__restrict __timer, struct tm *__restrict __tp)
//根据本地时间生成时间字符串
char *asctime (const struct tm *__tp);
char *asctime_r (const struct tm *__restrict __tp, char *__restrict __buf);
//根据日历时间生成时间字符串
char *ctime (const time_t *__timer);
char *ctime_r (const time_t *__restrict __timer, char *__restrict __buf);
//将带时区的时间转换成秒数
time_t mktime (struct tm *__tp);

//创建软件定时器的函数
int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue));
```

## delay

常见的延时相关接口有sleep, usleep, nanosleep，nsleep, clock_nanosleep。

## next_chapter

[返回目录](../README.md)

直接开始下一节说明: [Linux复杂应用层接口](./ch04-x2.linux_complex_api.md)
