# 1.Linux应用基础接口整理

对于Linux应用开发来说，除了C/C++语言支持的接口来说，还包含一系列管理系统、操作文件、系统时钟、内存的接口。这类系统是Linux内核提供操作的接口，在C语言中通过头文件添加，在应用中就可以调用实现。本篇文章参考如下书籍，有需要可以同步查看。

- 《UNIX环境高级编程》

接口目录如下。

- [dir_api-文件目录操作接口](#dir_api)
- [file_io-文件操作接口](#file_io)
- [flow_file_io-基于流的文件操作接口](#flow_file_io)
- [process_api-进程操作接口](#process_api)
- [system_api-系统管理接口](#system_api)
- [thread_api-线程管理接口](#thread_api)
- [env_api-系统环境操作接口](#env_api)
- [time_api-时间管理接口](#time_api)
- [format_api-格式化输入输出接口](#format_api)
- [mem_api-内存管理接口](#mem_api)
- [tty_api-串口接口说明](#tty_api)

## dir_api

用于管理目录的接口定义在<dirent.h>中，主要接口如下所示。

- 目录创建管理接口: opendir、readdir、closedir、mkdir和rmdir。
- 目录切换接口：chdir、fchdir。
- 获取当前工作目录的接口: getcwd

关于接口的具体说明如下所示。

```c
// 目录相关的头文件
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>

// 获取目录的管理指针
// @__name: 目录访问路径
// @return: 管理目录的资源
DIR *opendir (const char *__name);

// 读取目录的具体信息
// @__dirp: 已经请求的目录指针
// @return: 目录的具体信息指针
struct dirent *readdir (DIR *__dirp);

// 关闭获得的目录指针
// @__dirp: 已经请求的目录指针
// @return: 0表示关闭成功，负值返回对应错误码
int closedir (DIR *__dirp);

// 创建目录
// @__path: 目录访问路径
// @__mode: 创建目录的权限, 可以是0644，0777
// @return: 0表示创建成功，负值返回对应错误码
int mkdir (const char *__path, __mode_t __mode);

// 删除目录
// @pathname: 指向要删除的目录的路径名的指针
// @return: 0表示删除成功，负值返回对应错误码
int rmdir(const char *pathname);

// 改变当前进程工作目录
// @pathname: 指向要更改当前目录的路径名的指针
// @return: 0表示改变成功，负值返回对应错误码
int chdir(const char *pathname);

// 改变当前进程工作目录
// @fd: 文件描述符
// @return: 0表示改变成功，负值返回对应错误码
int fchdir(int fd)

// 获取当前工作目录
// @buf: 存储当前工作目录路径的缓冲区
// @size: 缓冲区大小
// @return: 返回当前所在的工作目录，buf为NULL时指向新分配的地址，用户需要自己释放
char *getcwd(char *buf, size_t size);
```

## file_io

用于管理文件的接口定义在<fcntl.h>中，主要接口如下所示。

- 文件内容操作接口：open、read、write、close、ioctl和lseek。
- 文件信息获取接口: stat、fstat和lstat。
- 文件同步接口：fsync、fflush。
- 文件信息修改接口: umask、rename、renameat、link、symlink和unlink。

具体说明如下所示。

```c
//文件处理的相关头文件
#include <fcntl.h>
#include <unistd>
#include <sys/stat.h>

// 打开文件，并返回一个文件描述符
// @pathname: 文件路径
// @flags: 文件打开的模式，常见的值有O_RDONLY(只读), O_WRONLY(只写), O_RDWR(可读写)，O_CREAT(创建文件), O_APPEND(追加)等
// @mode: 文件权限
// @return: 文件描述符
int open(const char *pathname, int flags, mode_t mode);

// 从文件描述符中读取数据
// @fd: 文件描述符
// @__buf: 读取的数据存放的缓冲区
// @__nbytes: 读取的数据字节数
// @return: 实际读取的字节数
ssize_t read(int __fd, void *__buf, size_t __nbytes);

// 向文件描述符中写入数据 
// @fd: 文件描述符
// @buf: 写入的数据缓冲区   
// @count: 写入的数据字节数
// @return: 实际写入的字节数
ssize_t write(int fd, const void *buf, size_t count);

// 关闭文件描述符
// @fd: 文件描述符
// @return: 0表示关闭成功，负值返回对应错误码
int close(int fd);

// 移动文件指针偏移地址,和read配合使用从指定起始地址读取数据
// @fd: 文件描述符
// @request: 设备特定的请求码
// @...: 可变参数
// @return: 0表示成功，负值表示失败
int ioctl(int fd, unsigned long int request, ...);

// 移动文件指针偏移地址,和read配合使用从指定起始地址读取数据
// @fd: 文件描述符
// @offset: 偏移量
// @whence: 偏移的起始位置
// @return: 0表示成功，负值表示失败
int lseek(int fd, off_t offset, int whence);

struct stat {
    dev_t     st_dev;         /* 包含文件的设备的ID */
    ino_t     st_ino;         /* inode号 */
    mode_t    st_mode;        /* 文件类型和模式 */
    nlink_t   st_nlink;       /* 硬链接的数量 */
    uid_t     st_uid;         /* 所有者的用户ID */
    gid_t     st_gid;         /* 所有者的组ID */
    dev_t     st_rdev;        /* 设备ID（如果是特殊文件） */
    off_t     st_size;        /* 总大小，以字节为单位 */
    blksize_t st_blksize;     /* 文件系统I/O的块大小 */
    blkcnt_t  st_blocks;      /* 分配的512B块的数量 */
    time_t    st_atime;       /* 最后访问时间 */
    time_t    st_mtime;       /* 最后修改时间 */
    time_t    st_ctime;       /* 最后状态更改时间 */
};

// 获取文件的状态信息
// @path: 文件路径
// @buf: 文件状态信息的缓冲区
// @return: 0表示成功，负值表示失败
int stat(const char *path, struct stat *buf);

// 获取文件的状态信息
// @fd: 文件描述符
// @buf: 文件状态信息的缓冲区
// @return: 0表示成功，负值表示失败
int fstat(int fd, struct stat *buf);

// 获取文件的状态信息(返回链接的信息，而不是文件本身信息)
// @path: 文件路径
// @buf: 文件状态信息的缓冲区
// @return: 0表示成功，负值表示失败
int lstat(const char *path, struct stat *buf);

// 用于确保文件的所有修改都被写入到磁盘中，包括文件的数据和元数据
// @fd: 文件描述符
// @return: 0表示成功，负值表示失败
int fsync(int fd);

// 用于确保流（stream）中的所有缓冲数据都被写入到文件中
// @fd: 文件描述符
// @return: 0表示成功，负值表示失败
int fflush(FILE *fd);

// 用于设置文件创建默认掩码的系统调用(文件接口定义的话，会优先使用本身的权限)
// @mask 一个八进制数，表示新的文件创建掩码。通常使用 0 到 0777 之间的值
// @return: 返回之前的文件创建掩码
mode_t umask(int mask);

// 重命名文件
// @oldpath: 原文件路径
// @newpath: 新文件路径
// @return: 0表示成功，负值表示失败
int rename(const char *oldpath, const char *newpath);

// 重命名文件
// @olddirfd: 原文件所在目录的文件描述符
// @oldname: 原文件名称
// @newdirfd: 新文件所在目录的文件描述符
// @newname: 新文件名称
// @return: 0表示成功，负值表示失败
int renameat(int olddirfd, const char *oldname, int newdirfd, const char *newname);

// 用于创建一个硬链接，即将一个现有的文件链接到另一个名称
// @oldpath: 原始文件的路径。
// @newpath: 新链接的路径。
// @return: 0表示成功，负值表示失败
int link(const char *oldpath, const char *newpath);

// 用于创建一个符号链接，即一个指向另一个文件或目录的特殊文件
// @target: 目标文件或目录的路径。
// @linkpath: 符号链接的路径。
// @return: 0表示成功，负值表示失败
int symlink(const char *target, const char *linkpath);

// unlink 函数用于删除一个文件或符号链接, 如果文件的链接计数变为 0，并且没有进程打开该文件，则文件的数据块将被释放
// @pathname: 要删除的文件或符号链接的路径
// @return: 0表示成功，负值表示失败
int unlink(const char *pathname);
```

## flow_file_io

基于流的文件管理接口同样定义在<fcntl.h>中，主要接口如下所示。

- 文件流内容操作的接口: fopen、fclose、fread、fwrite、fseek、fprintf、fscanf和rewind。
- 文件流字符操作的接口: getc、fgetc、getchar、putc、fputc和putchar。 
- 文件流字符串操作的接口: fgets、gets、fputs和puts。

具体说明如下所示。

```c
//相关头文件
#include <stdio.h>
#include <fcntl.h>

//打开文件，并返回一个文件流
// @__filename: 文件路径
// @__modes: 文件打开的模式，常见的值有r(只读), w(只写), a(追加)等
// @return: 文件流指针
FILE *fopen(const char *__filename, const char *__modes);

//关闭文件流
// @stream: 文件流指针
// @return: 0表示关闭成功，负值返回对应错误码
int fclose(FILE *stream);

//从文件流中读取数据
// @ptr: 读取的数据缓冲区
// @size: 读取的数据字节数
// @count: 读取的数据个数
// @stream: 文件流指针
// @return: 返回实际读取的字节数
size_t fread(void *ptr, size_t size, size_t count, FILE *stream);

//向文件流中写入数据
// @ptr: 写入的数据缓冲区
// @size: 写入的数据字节数
// @count: 写入的数据个数
// @stream: 文件流指针
// @return: 返回实际写入的元素个数
size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream);

//移动文件流的指针位置
// @stream: 文件流指针
// @offset: 偏移量
// @whence: 偏移的起始位置
// @return: 0表示成功，负值表示失败
int fseek(FILE *stream, long int offset, int whence);

//格式化输出到文件流中
// @stream: 文件流指针
// @format: 格式化字符串
// @...: 可变参数列表
// @return: 返回写入的字符数
int fprintf(FILE *stream, const char *format, ...);

//格式化输入从文件流中读取数据
// @stream: 文件流指针
// @format: 格式化字符串
// @...: 可变参数列表
// @return: 返回成功读取的参数个数
int fscanf(FILE *stream, const char *format, ...);

//重置文件流的指针位置
// @stream: 文件流指针
// @return: 0表示成功，负值表示失败
void rewind(FILE *stream);

//从文件流中读取一个字符
// @stream: 文件流指针
// @return: 返回读取的字符
int getc(FILE *stream);

//从文件流中读取一个字符
// @stream: 文件流指针
// @return: 返回读取的字符
int fgetc(FILE *stream);

//从标准输入中读取一个字符
// @return: 返回读取的字符
int getchar(void);

//向文件流中写入一个字符
// @c: 写入的字符
// @stream: 文件流指针
// @return: 0表示成功，负值表示失败
int putc(int c, FILE *stream);

//向文件流中写入一个字符
// @c: 写入的字符
// @stream: 文件流指针
// @return: 0表示成功，负值表示失败
int fputc(int c, FILE *stream);

//向标准输出中写入一个字符
// @c: 写入的字符
// @return: 0表示成功，负值表示失败
int putchar(int c);

//从文件流中读取一行数据
// @s: 存储读取数据的缓冲区
// @stream: 文件流指针
// @return: 返回读取的字符串
char *fgets(char *s, int size, FILE *stream);

//从标准输入中读取一行数据
// @s: 存储读取数据的缓冲区
// @return: 返回读取的字符串
char *gets(char *s);

//向文件流中写入一行数据
// @s: 存储写入数据的缓冲区
// @stream: 文件流指针
// @return: 返回写入的字符串
int fputs(const char *s, FILE *stream);

//向标准输出中写入一行数据
// @s: 存储写入数据的缓冲区
// @return: 返回写入的字符串
int puts(const char *s);
```

## process_api

管理进程的接口定义在<unistd.h>中，主要接口如下所示。

- 进程管理接口：fork、exit、abort、axexit。
- 进程信息接口：getpid、getppid、getuid。

具体说明如下所示。

```c
//系统处理的相关头文件
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <unistd.h>

// 创建一个新的进程，新进程是调用进程的副本
// @return: 进程得pid，0表示子进程，正值表示父进程，负值表示fork失败
__pid_t fork(void);

// 终止当前进程
// @status: 进程退出状态
// @return: 进程退出状态
void exit(int status);

// 异常终止当前进程
void abort(void);

// 注册一个退出函数，在应用结束或者exit调用时执行
// @func: 退出函数
// @return: 0表示成功，负值表示失败
int atexit(void (*func)(void));

// 获得当前进程的pid值
// @return: 进程得pid
__pid_t getpid(void);

// 获得当前进程的父进程pid值
// @return: 进程得pid
__pid_t getppid(void);

// 获得当前进程的uid值
// @return: 进程得uid
__uid_t getuid (void);
```

## system_api

系统管理的接口定义在<unistd.h>中，主要接口如下所示。

- 系统调用接口：getopt、perror、system、signal。
- 文件权限接口：chmod、fchmod、fchmodat、chown。

具体说明如下所示。

```c
//系统处理的相关头文件
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <sys/stat.h>

// 解析命令行参数，存储到optarg字符串中
// @argc: 参数个数
// @argv: 参数数组
// @optstring: 选项字符串
// @return: 读取的选项字符
int getopt(int argc, char *const argv[], const char *optstring);

// 打印错误信息
// @s: 错误信息
void perror(const char *s);

// 执行调用其它程序或者指令
// @__command: 指令
// @return: 0表示成功，负值表示失败
int system (const char *__command);

// 注册信号处理函数
// @signum: 处理的信号，常见SIGINT 表示中断信号（通常由用户按下 Ctrl+C 产生），SIGTERM 表示终止信号
// @handler: 信号处理函数
// @return: 0表示成功，负值表示失败
int signal(int signum, void (*handler)(int));

// 改变文件的权限
// @path: 文件路径
// @mode: 文件权限
// @return: 0表示成功，负值表示失败
int chmod (const char *__path, __mode_t __mode);

// 改变文件的权限
// @fd: 文件描述符
// @mode: 文件权限
// @return: 0表示成功，负值表示失败
int fchmod (int __fd, __mode_t __mode);

// 改变文件的权限(pathname为绝对地址，fd为AT_FDCWD, pathname为相对地址)
// @fd: 文件描述符
// @path: 文件路径
// @mode: 文件权限
// @flag: 标志位
// @return: 0表示成功，负值表示失败
int fchmodat (int __fd, const char *__path, __mode_t __mode, int __flag);

// 改变文件的所有者
// @path: 文件路径
// @owner: 文件所有者
// @group: 文件所属组
// @return: 0表示成功，负值表示失败
int chown (const char *__path, __uid_t __owner, __gid_t __group);

```

## thread_api

线程创建的和处理的接口定义在<pthread.h>中，主要接口如下所示。

- 线程创建和销毁接口：pthread_create、pthread_join、pthread_exit、pthread_detach。
- 互斥锁接口：pthread_mutex_init、pthread_mutexattr_init、pthread_mutexattr_settype、pthread_mutex_lock、pthread_mutex_unlock、pthread_mutex_destroy。
- 自旋锁接口：pthread_spin_init、pthread_spin_lock，pthread_spin_unlock, pthread_spin_trylock。

具体说明如下所示。

```c
//线程相关的头文件
#include <pthread.h>

//创建线程
// @tid: 线程id
// @attr: 线程属性
// @start_routine: 线程函数
// @arg: 线程函数的参数
// @return: 0表示成功，负值表示失败
int pthread_create(pthread_t *tid, const pthread_arrt_t* attr, void*(*start_routine)(void *), void* arg);  

//等待线程结束
// @thread: 线程id
// @retval: 线程返回值
// @return: 0表示成功，负值表示失败
int pthread_join(pthread_t thread, void **retval);

//线程退出
// @retval: 线程返回值
void pthread_exit(void * retval);

//分离线程，被分离的线程结束时自动释放资源
// @tid: 线程id
// @return: 0表示成功，负值表示失败
int pthread_detach(pthread_t tid);

//互斥锁
pthread_mutex_t m_lock;
pthread_mutexattr_t attr;

// 互斥锁初始化
// @mutex: 互斥锁
// @attr: 互斥锁属性
// @return: 0表示成功，负值表示失败
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);

// 互斥锁属性初始化
// @attr: 互斥锁属性
// @return: 0表示成功，负值表示失败
int pthread_mutexattr_init(pthread_mutexattr_t *attr);

// 互斥锁属性设置
// @attr: 互斥锁属性
// @type: 互斥锁类型，常见的PTHREAD_MUTEX_NORMAL(不带死锁检测)，PTHREAD_MUTEX_ERRORCHECK(带死锁检测)，PTHREAD_MUTEX_RECURSIVE(递归互斥锁)，PTHREAD_MUTEX_DEFAULT(默认属性)
// @return: 0表示成功，负值表示失败
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);

// 互斥锁销毁
// @mutex: 互斥锁
// @return: 0表示成功，负值表示失败
int pthread_mutex_destroy(pthread_mutex_t *mutex);

// 互斥锁加锁
// @mutex: 互斥锁
// @return: 0表示成功，负值表示失败
int pthread_mutex_lock(pthread_mutex_t *mutex);

// 互斥锁解锁
// @mutex: 互斥锁
// @return: 0表示成功，负值表示失败
int pthread_mutex_unlock(pthread_mutex_t *mutex);

//自旋锁
pthread_spinlock_t m_spinlock;

// 自旋锁初始化
//  @lock: 自旋锁
//  @pshared: 0表示线程间共享，非0表示进程间共享
//  @return: 0表示成功，负值表示失败
int pthread_spin_init(pthread_spinlock_t *lock, int pshared);

// 自旋锁销毁
//  @lock: 自旋锁
//  @return: 0表示成功，负值表示失败
int pthread_spin_destroy(pthread_spinlock_t *lock);

// 自旋锁加锁
//  @lock: 自旋锁
//  @return: 0表示成功，负值表示失败
int pthread_spin_lock(pthread_spinlock_t *lock);

// 自旋锁解锁
//  @lock: 自旋锁
//  @return: 0表示成功，负值表示失败
int pthread_spin_unlock(pthread_spinlock_t *lock);

// 自旋锁尝试加锁
//  @lock: 自旋锁
//  @return: 0表示成功，负值表示失败
int pthread_spin_trylock(pthread_spinlock_t *lock);
```  

## env_api

系统环境变量管理的接口定义在<stdlib.h>中，主要接口如下所示。

- 环境变量处理接口：getenv、getenv、unsetenv、putenv、clearenv。

具体说明如下所示。

```cpp
// 系统环境相关的头文件
#include <stdlib.h>

// 获取系统环境变量
// @name: 环境变量名称
// @return: 环境变量的值
char *getenv(const char *name);

// 添加和修改环境变量
// @name: 环境变量名称
// @value: 环境变量的值
// @rewrite: 0表示不覆盖，非0表示覆盖
// @return: 0表示成功，负值表示失败
int setenv(const char *name, const char *value, int rewrite);

// 删除环境变量
// @name: 环境变量名称
// @return: 0表示成功，负值表示失败
int unsetenv(const char *name);

//写入环境变量，覆盖或者添加, 和setenv功能类似，实现上格式为name=string
// @str: 指向一个字符串的指针，该字符串的格式为 "name=value"，其中 "name" 是环境变量的名称，"value" 是环境变量的值
// @return: 0表示成功，负值表示失败
int putenv(char *str);

//清除环境变量
// @return: 0表示成功，负值表示失败
int clearenv(void);
```

## time_api

系统时间获取和处理的接口定义在<sys/time.h>中，包含了一系列获取时间，并进行转换的功能。

- 时间获取接口：time、gmtime、gmtime_r、gettimeofday、localtime、localtime_r。
- 时间转换和设置接口：asctime，asctime_r、ctime、ctime_r、mktime。
- 系统软件定时间：setitimer。

```cpp
//目录相关的头文件
#include <sys/time.h>

// 获取系统的日历时间，以1970-1-1, 00:00:00开始计算的seconds值
// @timer: 一个指向 time_t 类型的指针，用于存储返回的日历时间。如果 timer 为 NULL，则函数只返回当前的日历时间，而不存储它
// @return: 如果__timer不为NULL，存储在timer指向位置，并返回时间值，timer为NULL，返回时间值，发生错误，函数返回-1
time_t time (time_t *__timer);

// 根据日历时间获取GMT时间的函数
// @timer: 一个指向 time_t 类型的指针
// @return: 返回一个指向 struct tm 类型的指针，该指针指向的结构体包含了 GMT 时间的各个字段
// struct tm格式
struct tm {
    int tm_sec;   // 秒，取值范围 0-59
    int tm_min;   // 分，取值范围 0-59
    int tm_hour;  // 时，取值范围 0-23
    int tm_mday;  // 日，取值范围 1-31
    int tm_mon;   // 月，取值范围 0-11（0 表示一月）
    int tm_year;  // 年，从1900开始计算
    int tm_wday;  // 星期，取值范围 0-6（0 表示星期日）
    int tm_yday;  // 一年中的第几天，取值范围 0-365
    int tm_isdst; // 夏令时标志，正数表示夏令时，0表示非夏令时，负数表示信息不可用
};
struct tm *gmtime (const time_t *__timer);

// 根据日历时间获取GMT时间的函数(使用用户缓冲区而不是内部缓冲区)
// @timer: 一个指向 time_t 类型的指针
// @tp: 一个指向 struct tm 类型的指针
// @return: 返回一个指向 struct tm 类型的指针，该指针指向的结构体包含了 GMT 时间的各个字段
struct tm *gmtime_r (const time_t *__restrict __timer,  struct tm *__restrict __tp)

// 获取当前时间和时区的函数
// @tv: 一个指向 struct timeval 类型的指针，用于存储返回的时间值
// @tz: 一个指向 struct timezone 类型的指针，用于存储返回的时区信息
// @return: 0表示成功，负值表示失败
int gettimeofday(struct timeval *tv, struct timezone *tz);

// 根据日历时间获取本地时间的函数(根据/etc/localtime文件)
// @timer: 一个指向 time_t 类型的指针
// @return: 返回一个指向 struct tm 类型的指针，该指针指向的结构体包含了本地时间的各个字段
struct tm *localtime (const time_t *__timer);

// 根据日历时间获取本地时间的函数(使用用户缓冲区而不是内部缓冲区)
// @timer: 一个指向 time_t 类型的指针
// @tp: 一个指向 struct tm 类型的指针
// @return: 返回一个指向 struct tm 类型的指针，该指针指向的结构体包含了本地时间的各个字段
struct tm *localtime_r (const time_t *__restrict __timer, struct tm *__restrict __tp)

// 根据tm时间结构生成字符串
// @tp: 一个指向 struct tm 类型的指针
// @return: 返回一个指向字符串的指针，该字符串包含了 tm 时间结构的各个字段的字符串表示
char *asctime (const struct tm *__tp);

// 根据tm时间结构生成字符串(使用用户缓冲区而不是内部缓冲区)
// @tp: 一个指向 struct tm 类型的指针
// @buf: 一个指向字符数组的指针，用于存储生成的字符串
// @return: 返回一个指向字符数组的指针，该指针指向的字符串包含了 tm 时间结构的各个字段的字符串表示
char *asctime_r (const struct tm *__restrict __tp, char *__restrict __buf);

// 根据日历时间生成时间字符串
// @timer: 一个指向 time_t 类型的指针
// @return: 返回一个指向字符串的指针，该字符串包含了日历时间的各个字段的字符串表示
char *ctime (const time_t *__timer);

//根据日历时间生成时间字符串(使用用户缓冲区而不是内部缓冲区)
// @timer: 一个指向 time_t 类型的指针
// @buf: 一个指向字符数组的指针，用于存储生成的字符串
char *ctime_r (const time_t *__restrict __timer, char *__restrict __buf);

//将带时区的时间转换成秒值
// @tp: 一个指向 struct tm 类型的指针
// @return: 返回一个 time_t 类型的值，表示日历时间
time_t mktime (struct tm *__tp);

struct timeval {
    time_t      tv_sec;     /* seconds */
    suseconds_t tv_usec;    /* microseconds */
};

struct timezone {
    int tz_minuteswest;    //表示本地时区相对于格林威治标准时间（GMT）的分钟数偏移量。例如，对于美国东部时间（EST），tz_minuteswest 的值为 -300（即 5 小时）
    int tz_dsttime;        // 表示夏令时（DST）的修正类型，通常取值为 DST_NONE、DST_USA、DST_AUST、DST_WET、DST_MET、DST_EET、DST_CAN、DST_GB、DST_RUM、DST_TUR、DST_AUSTALT 等
};

//创建软件定时器的函数，超时后会触发SIGALRM信号，使用signal函数捕捉该信号
// @which: 定时器类型，ITIMER_REAL(实时定时器)，ITIMER_VIRTUAL(虚拟定时器)，ITIMER_PROF(性能定时器)
// @value: 一个指向 struct itimerval 类型的指针，该指针指向的结构体包含了定时器的初始值和间隔值
// @ovalue: 一个指向 struct itimerval 类型的指针，该指针指向的结构体包含了定时器的初始值和间隔值
// @return: 0表示成功，负值表示失败
struct itimerval {
    struct timeval it_interval; // 定时器的间隔值
    struct timeval it_value;    // 定时器的初始值
};
int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue));
```

## format_api

格式化输入输出接口是C语言中用于处理输入和输出的一组函数，它们允许你以特定的格式读取或写入数据。

- 输出函数: printf、fprintf、dprintf等
- 输入函数: snprintf、scan、，fscanf、sscanf等

具体说明如下所示。

```c
// 相关头文件
#include <stdio.h>

// 格式化输出函数
// @format: 格式化字符串
// @...: 可变参数列表
// @return: 返回实际输出的字符数
int printf(const char *format, ...);

// 格式化输出函数(用于文件流)
// @stream: 文件流指针
// @format: 格式化字符串
// @...: 可变参数列表
// @return: 返回实际输出的字符数
int fprintf(FILE *stream, const char *format,...);

// 格式化输出函数(用于文件描述符)
// @fd: 文件描述符
// @format: 格式化字符串
// @...: 可变参数列表
// @return: 返回实际输出的字符数
int dprintf(int fd, const char *format,...);

// 格式化输出函数(用于字符串)
// @str: 字符串指针
// @format: 格式化字符串
// @...: 可变参数列表
// @return: 返回实际输出的字符数
int sprintf(char *str, const char *format,...);

// 格式化输出函数(用于字符串)
// @str: 字符串指针
// @size: 字符串大小
// @format: 格式化字符串
// @...: 可变参数列表
// @return: 返回实际输出的字符数
int snprintf(char *str, size_t size, const char *format,...);

// 格式化输入函数
// @format: 格式化字符串
// @...: 可变参数列表
// @return: 返回实际输入的字符数
int scanf(const char *format,...);

// 格式化输入函数(用于文件流)
// @stream: 文件流指针
// @format: 格式化字符串
// @...: 可变参数列表
// @return: 返回实际输入的字符数
int fscanf(FILE *stream, const char *format,...);

// 格式化输入函数(用于字符串)
// @str: 字符串指针
// @format: 格式化字符串
// @...: 可变参数列表
// @return: 返回实际输入的字符数
int sscanf(const char *str, const char *format,...);
```

## mem_api

内存管理包含内存的申请，释放等即可。

- 内存管理接口：malloc、free、reallc，calloc。

详细说明如下所示。

```c
// 相关头文件
#include <stdlib.h>

// 内存申请函数
// @size: 内存大小
// @return: 返回申请的内存地址
void *malloc(size_t size);

// 内存释放函数
// @ptr: 内存地址
void free(void *ptr);

// 内存重新分配函数
// @ptr: 内存地址
// @size: 内存大小
// @return: 返回重新分配的内存地址
void *realloc(void *ptr, size_t size);

// 内存申请函数(申请并初始化内存)
// @nmemb: 元素个数
// @size: 元素大小
// @return: 返回申请的内存地址
void *calloc(size_t nmemb, size_t size);
```

## tty_api

串口相关的接口主要定义在<termios.h>中，主要接口如下所示。

- 串口文件管理接口：open、close、read、write、ioctl。
- 串口属性管理接口：tcgetattr、tcsetattr、tcflush、cfsetispeed、tcdrain。

详细说明如下所示。

```c
//相关头文件
#include <termios.h>
#include <fcntl.h>
#include <stdio.h>

//打开tty设备
// @path: tty设备路径
// @oflag: 打开模式, 可以是O_RDONLY, O_WRONLY, O_RDWR
// @return: 0表示打开成功，负值返回对应错误码
int open(const char *path, int oflag);

//关闭tty设备
// @fd: tty设备描述符
// @return: 0表示关闭成功，负值返回对应错误码
int close(int fd);

//从tty设备读取数据
// @fd: tty设备描述符
// @buf: 数据缓冲区
// @count: 数据缓冲区大小
// @return: 0表示读取成功，负值返回对应错误码
ssize_t read(int fd, void *buf, size_t count);

//向tty设备写入数据
// @fd: tty设备描述符
// @buf: 数据缓冲区
// @count: 数据缓冲区大小
// @return: 0表示写入成功，负值返回对应错误码
ssize_t write (int fd, const void *buf, size_t count);

//控制tty设备的接口
// @fd: tty设备描述符
// @cmd: 控制命令
// @arg: 控制参数
// @return: 0表示控制成功，负值返回对应错误码
int ioctl (int fd, int cmd, ...);

struct termios {
    tcflag_t c_iflag;      // 输入模式标志
    tcflag_t c_oflag;      // 输出模式标志
    tcflag_t c_cflag;      // 控制模式标志
    tcflag_t c_lflag;      // 本地模式标志
    cc_t c_cc[NCCS];       // 控制字符
};

//Linux串口接收二进制字符0x11，0x13, 0x0d等特殊字符串丢弃和转换(如下设置避免处理)
term.c_cflag |= CLOCAL | CREAD;
term.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
term.c_oflag &= ~OPOST;
term.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);

//获取tty设备的配置
// @fd: tty设备描述符
// @termios_p: tty设备配置
// @return: 0表示获取成功，负值返回对应错误码
int tcgetattr (int fd, struct termios *termios_p);

//设置tty设备的配置
// @fd: tty设备描述符
// @optional_actions: 可选操作
// @termios_p: tty设备配置
// @return: 0表示设置成功，负值返回对应错误码
int tcsetattr (int fd, int optional_actions, const struct termios *termios_p);

//刷新tty设备的输入输出缓冲区
// @fd: tty设备描述符
// @queue_selector: 缓冲区选择
// @return: 0表示刷新成功，负值返回对应错误码
int tcflush (int fd, int queue_selector);

//设置tty设备的波特率
// @fd: tty设备描述符
// @speed: 波特率
// @return: 0表示设置成功，负值返回对应错误码
int cfsetospeed (struct termios *__p, speed_t __speed);

//等待tty设备的输出缓冲区清空
// @fd: tty设备描述符
// @return: 0表示等待成功，负值返回对应错误码
int tcdrain (int fd);
```

## next_chapter

[返回目录](../README.md)

直接开始下一节说明: [Linux复杂应用层接口](./ch04-x2.linux_complex_api.md)
