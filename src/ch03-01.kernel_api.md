# kernel_driver_api

在学习和分析Linux驱动的时候，感受最大的问题是不理解内核提供的很多接口的功能和说明。在本篇中整理总结在开发中遇到的接口，对于具体功能依靠Linux/Documentation目录下说明, 源码注释，在根据自己的理解总结。对这些接口的整理，也是梳理重新认识Linux框架和代码的过程，个人受益匪浅。另外本篇中肯定因为个人认知的局限，有纰漏的地方，因此会长期进行更新。

- [platform总线接口](#platform_bus_api)
  - [platform_driver_register](#platform_driver_register)
  - [platform_driver_unregister](#platform_driver_unregister)
  - [platform_device_register](#platform_device_register)
  - [platform_device_unregister](#platform_device_unregister)
  - [platform_add_devices](#platform_add_devices)
  - [platform_get_irq](#platform_get_irq)
  - [platform_irq_count](#platform_irq_count)
  - [platform_get_irq_byname](#platform_get_irq_byname)
  - [platform_get_resource](#platform_get_resource)
  - [platform_get_resource_byname](#platform_get_resource_byname)
- [i2c总线接口](#i2c_bus_api)
  - [i2c_add_driver](#i2c_add_driver)
  - [i2c_del_driver](#i2c_del_driver)
  - [i2c_transfer](#i2c_transfer)
  - [i2c_type](#i2c_type)
  - [i2c_xxx_adapter](#i2c_xxx_adapter)
- [spi总线接口](#spi_bus_api)
  - [spi_register_driver](#spi_register_driver)
  - [spi_unregister_driver](#spi_unregister_driver)
  - [spi_message_init](#spi_message_init)
  - [spi_message_add_tail](#spi_message_add_tail)
  - [spi_sync](#spi_sync)
  - [spi_sync_transfer](#spi_sync_transfer)
- [device创建接口](#device_create)
- [设备树接口](#devicetree_api)
  - [of_gpio_named_count](#of_gpio_named_count)

## platform_bus_api

### platform_driver_register

- 功能: 在platform总线中注册驱动
- 目录: include/linux/platform_device.h
        drivers/base/platform.c

```c
//函数原型
#define platform_driver_register(drv) \
    __platform_driver_register(drv, THIS_MODULE)
int __platform_driver_register(struct platform_driver *drv, struct module *owner);

//参数
drv: 驱动加载时，总线需要访问的驱动结构体
owner：驱动模块的拥有者，固定为THIS_MODULE
返回: 0表示执行成功，其它值表示执行出错

//例程说明
/* 
用于匹配platform总线下的节点，可通过ls /sys/bus/platform/devices/查看支持的接口
匹配属性为compatible，如usr_beep的属性查看
cat /sys/bus/platform/devices/usr_beep/of_node/compatible
*/
static const struct of_device_id of_match_beep[] = {
    { .compatible = "rmk,usr-beep"},
    { /* Sentinel */ }
};
MODULE_DEVICE_TABLE(of, of_match_beep);

static struct platform_driver platform_driver = {
    .driver = {
        .name = "usr_beep",     
        .of_match_table = of_match_beep,  
    },
    .probe = beep_probe,
    .remove = beep_remove,
};
platform_driver_register(&platform_driver);

/*
注意: 
有设备树情况下，在总线加载时会解析设备树并创建指定总线下的设备(如/sys/bus/i2c/devices/下)
无设备树情况，需要自己手动创建设备, 此时使用id_table匹配。
*/
```

### platform_driver_unregister

- 功能: platform总线移除指定驱动，会调用注册时指定的.remove函数
- 目录: drivers/base/platform.c

```c
//函数原型
void platform_driver_unregister(struct platform_driver *drv)

//参数
drv: 驱动移除时，总线需要访问的驱动结构体

//例程
platform_driver_unregister(&platform_driver);
```

### platform_device_register

- 功能: 在platform总线中增加设备
- 目录: include/linux/platform_device.h
        drivers/base/platform.c

```c
//函数原型
int platform_device_register(struct platform_device *pdev)

//参数
pdev: 设备注册时，总线需要访问的设备结构体
返回: 0表示执行成功，其它值表示执行出错

//例程
static struct w1_gpio_platform_data foo_w1_gpio_pdata = {
    .ext_pullup_enable_pin  = -EINVAL,
};

static struct platform_device foo_w1_device = {
    .name       = "w1-gpio", //设备和驱动匹配时，对应的驱动名称
    .id         = -1,
    .dev.platform_data  = &foo_w1_gpio_pdata,
};
platform_device_register(&foo_w1_device);

/* 
注意: 
有设备树时，内核启动时解析设备树自动创建
不使用设备树时需要自己手动创建总线，驱动使用id_table匹配name选项。
目前主流是设备树方案，接口很少使用。
*/
```

### platform_device_unregister

- 功能: 在platform总线中移除设备
- 目录: include/linux/platform_device.h
        drivers/base/platform.c

```c
//函数原型
void platform_device_unregister(struct platform_driver *drv)

//参数
drv:设备移除时，总线需要访问的设备结构体

//例程
platform_device_unregister(&foo_w1_device);
```

### platform_add_devices

- 功能: 在platform中注册一组设备
- 目录: include/linux/platform_device.h
        drivers/base/platform.c

```c
//函数原型
int platform_add_devices(struct platform_device **devs, int num);

//参数
devs: 设备注册时，总线需要访问的设备结构体数组
nmu：注册的设备个数
返回: 0表示注册成功，其它值表示注册失败(任意一个失败都会直接返回)

//例程
static struct platform_device *devices[] __initdata = {
    &kb3886bl_device,
};
platform_add_devices(devices, ARRAY_SIZE(devices));

/*
注意:由platform_add_devices注册的设备，仍然用platform_device_unregister进行移除
*/
```

### platform_get_irq

- 功能: 获取platform总线下设备中interrupts属性内的irq号
- 目录: include/linux/platform_device.h
        drivers/base/platform.c

```c
//函数原型
int platform_get_irq(struct platform_device *dev, unsigned int num)

//参数
dev: platform总线下匹配的设备
num：在interrupt属性中的编号
返回: 正值和0表示返回的中断号，负值表示失败

//例程
//中断线号带两个参数类型，表示中断控制器为gpio1，对应gpio1的9号中断
interrput-parent = <&gpio1>;
interrupts = <9 IRQ_TYPE_LEVEL_LOW>;  
//中断线号带三个参数类型
//interrupts = <中断类型，中断号偏移值，中断触发类型>
//中断类型
//GIC_IPI: inter processer interrupt, 中断号0~15
//GIC_PPI: peripheral processer interrupt, 中断号16~31
//GIC_SPI：shared processer interrupt, 中断号32~32+224
//GPI_SGI: software generated interruot
//中断触发类型
//IRQ_TYPE_NONE         0
//IRQ_TYPE_EDGE_RISING  1
//IRQ_TYPE_EDGE_FALLING 2
//IRQ_TYPE_EDGE_BOTH    3
//IRQ_TYPE_LEVEL_HIGH   4
//IRQ_TYPE_LEVEL_LOW    5
interrupts = <GIC_SPI 23 1> //对应中断线号32+23=55
int irq = platform_get_irq(pdev, 0); //取interrupts位置0对应的中断编号
```

### platform_irq_count

- 功能: 获取platform总线下指定设备中interrupts的个数
- 目录: include/linux/platform_device.h
        drivers/base/platform.c

```c
//函数原型
int platform_irq_count(struct platform_device *dev);

//参数
dev: platform总线下匹配的设备
返回: 正值表示查询到的数目，负值表示未查询到

//例程
int count = platform_irq_count(pdev);
```

### platform_get_irq_byname

- 功能：获取platform总线下指定设备带名称interrupt的irq编号
- 目录: include/linux/platform_device.h
        drivers/base/platform.c

```c
//函数原型
int platform_get_irq_byname(struct platform_device *dev, const char *name)

//参数
dev: platform总线下匹配的设备
name: 设备结构中的属性
返回: 中断资源中第一个的irq值

//例程
//interrupt-name指定中断的name，通过platform_get_irq_byname访问
interrupts = <0 8 IRQ_TYPE_LEVEL_HIGH>,
            <0 9 IRQ_TYPE_LEVEL_HIGH>;
interrupt-names = "edma-tx", "edma-err";
fsl_edma->errirq = platform_get_irq_byname(pdev, "edma-err")
```

### platform_get_resource

- 功能：获取platform总线下指定设备的资源类型
- 目录: include/linux/platform_device.h
        drivers/base/platform.c

```c
//函数原型
struct resource *platform_get_resource(struct platform_device *dev, unsigned int type, unsigned int num);

//参数
dev: platform总线下匹配的设备
type: 资源的类型, IORESOURCE_IO, IORESOURCE_MEM, IORESOURCE_REG, IORESOURCE_IRQ, IORESOURCE_DMA, IORESOURCE_BUS
index: 资源的编号
返回: NULL表示获取失败，其它返回resoure对应的指针地址

//例程
//在设备树加载时，会将设备树内的节点中属性转换成对应的资源，后续可以通过此方法读取
gpio = <&gpio5 2 GPIO_ACTIVE_LOW>;       //IORESOURCE_IO
reg = <0x3c>;                            //IORESOURCE_MEM
interrupts = <18 IRQ_TYPE_EDGE_FALLING>; //IORESOURCE_IRQ

int irq;
struct resource *res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
if(!res)
    irq = res->start;
```

### platform_get_resource_byname

- 功能：获取platform总线下指定设备对应名称的资源结构
- 目录: include/linux/platform_device.h
        drivers/base/platform.c

```c
//函数原型
struct resource *platform_get_resource_byname(struct platform_device *dev, unsigned int type, const char *name)

//参数
dev: platform总线下匹配的设备
type: 资源的类型, IORESOURCE_IO, IORESOURCE_MEM, IORESOURCE_REG, IORESOURCE_IRQ, IORESOURCE_DMA, IORESOURCE_BUS
name: 资源的名称
返回: NULL表示获取失败，其它返回resoure对应的指针地址

//例程
//interrupt-name指定中断的name，通过platform_get_resource_byname访问
interrupts = <0 8 IRQ_TYPE_LEVEL_HIGH>,
            <0 9 IRQ_TYPE_LEVEL_HIGH>;
interrupt-names = "edma-tx", "edma-err";
fsl_edma->errirq = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "edma-err")
```

## i2c_bus_api

### i2c_add_driver

- 功能：在i2c总线下注册驱动
- 目录: include/linux/i2c.h
        drivers/i2c/i2c-core-base.c

```c
//函数原型
#define i2c_add_driver(driver) \
    i2c_register_driver(THIS_MODULE, driver)
int i2c_register_driver(struct module *owner, struct i2c_driver *driver);

//参数
owner：驱动模块的拥有者，固定为THIS_MODULE
driver: 驱动加载时，总线需要访问的驱动结构体
返回: 0表示执行成功，其它值表示执行出错

//例程
//设备树
ap3216@1e {
    compatible = "rmk,ap3216";
    reg = <0x1e>;
};

/* 
用于匹配i2c总线下的节点，可通过ls /sys/bus/i2c/devices/查看支持的接口
总线匹配成功设备树后创建资源，这里每个设备节点对应i2c_adpater接口点。
匹配属性为compatible，另外支持设备的名称为1-0038的格式，其中1为i2c编号，38为i2c设备地址
*/
static const struct of_device_id ap3216_of_match[] = {
    { .compatible = "rmk,ap3216" }, //匹配的为i2c总线下设备节点的compatible属性
    { /* Sentinel */ }
};
static struct i2c_driver ap3216_driver = {
    .probe = ap3216_probe,
    .remove = ap3216_remove,
    .driver = {
        .owner = THIS_MODULE,
        .name = "ap3216",
        .of_match_table = ap3216_of_match, 
    },
};
int ret = i2c_add_driver(&ap3216_driver);
```

### i2c_del_driver

- 功能: i2c总线移除指定驱动，会调用注册时指定的.remove函数
- 目录: include/linux/i2c.h
        drivers/i2c/i2c-core-base.c

```c
//函数原型
void i2c_del_driver(struct i2c_driver *driver);

//参数
driver: 驱动移除时，总线需要访问的驱动结构体
返回: 0表示执行成功，其它值表示执行出错

//例程
int ret = i2c_del_driver(&ap3216_driver);
```

### i2c_transfer

- 功能: i2c传输一组或者多组i2c消息msg.
- 目录: include/linux/i2c.h
        drivers/i2c/i2c-core-base.c

```c
//函数原型
int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)

//参数
adap: i2c适配器，i2c作为总线可以挂载多个i2c设备，这里每个设备创建一个适配器结构并指定编号，当指定adap时就可以获取对应的外部器件资源。
msgs: i2c传输的数据指针数组
num: 传递消息的个数
返回: 成功返回传递消息的个数，其它则为失败

//例程
struct i2c_msg msgs[2];
__be16 wbuf = cpu_to_be16(reg);
int ret;

msgs[0].flags = 0;
msgs[0].addr  = client->addr;   //i2c地址
msgs[0].len   = 2;
msgs[0].buf   = (u8 *)&wbuf;

msgs[1].flags = I2C_M_RD;
msgs[1].addr  = client->addr;
msgs[1].len   = len;
msgs[1].buf   = buf;

ret = i2c_transfer(client->adapter, msgs, 2);
```

### i2c_type

- i2c匹配成功后系统获取得结构, 一般不会使用得属性，会直接省略掉。

```c
struct i2c_adapter {
    unsigned int class;             /* classes to allow probing for */
    const struct i2c_algorithm *algo; /* the algorithm to access the bus */
    void *algo_data;

    /* data fields that are valid for all devices */
    const struct i2c_lock_operations *lock_ops;
    struct rt_mutex bus_lock;
    struct rt_mutex mux_lock;

    int timeout;            /* in jiffies */
    int retries;
    struct device dev;      /* the adapter device */
    unsigned long locked_flags; /* owned by the I2C core */
    #define I2C_ALF_IS_SUSPENDED    0
    #define I2C_ALF_SUSPEND_REPORTED    1

    int nr;
    char name[48];
    struct completion dev_released;

    struct mutex userspace_clients_lock;
    struct list_head userspace_clients;

    struct i2c_bus_recovery_info *bus_recovery_info;
    const struct i2c_adapter_quirks *quirks;

    struct irq_domain *host_notify_domain;
    struct regulator *bus_regulator;
};

struct i2c_client {
    unsigned short flags;                       /* div., see below */
        #define I2C_CLIENT_PEC  0x04            /* Use Packet Error Checking */
        #define I2C_CLIENT_TEN  0x10            /* we have a ten bit chip address */
        #define I2C_CLIENT_SLAVE    0x20        /* we are the slave */
        #define I2C_CLIENT_HOST_NOTIFY  0x40    /* We want to use I2C host notify */
        #define I2C_CLIENT_WAKE     0x80        /* for board_info; true iff can wake */
        #define I2C_CLIENT_SCCB     0x9000      /* Use Omnivision SCCB protocol */

    unsigned short addr;                        /* chip address - NOTE: 7/10bit */
    /* addresses are stored in the */
    /* _LOWER_ 7 bits */
    char name[I2C_NAME_SIZE];
    struct i2c_adapter *adapter;                /* the adapter we sit on */
    struct device dev;                          /* the device structure */
    int init_irq;                               /* irq set at initialization */
    int irq;                                    /* irq issued by device */
    struct list_head detected;
    #if IS_ENABLED(CONFIG_I2C_SLAVE)
    i2c_slave_cb_t slave_cb;                    /* callback for slave mode	*/
    #endif
    void *devres_group_id;                      /* ID of probe devres group	*/
};
```

### i2c_xxx_adapter

不使用设备树情况，需要自己在i2c总线下添加设备节点时涉及得接口，当使用设备树，这部分由内核加载设备树时解析自动生成，用户不需要自己开发。考虑到文档复杂度问题，这里只列出功能，不详细解析。

```c
//在i2c总线下添加设备节点
int i2c_add_adapter(struct i2c_adapter *adap);

//在i2c总线下添加内核管理的设备节点
int devm_i2c_add_adapter(struct device *dev, struct i2c_adapter *adapter);

//删除i2c总线中的设备节点
void i2c_del_adapter(struct i2c_adapter *adap)

//根据编号获得i2c适配器资源
struct i2c_adapter *i2c_get_adapter(int nr);

//释放获得得i2c适配器资源
void i2c_put_adapter(struct i2c_adapter *adap)
```

## spi_bus_api

### spi_register_driver

- 功能：在spi总线下注册驱动
- 目录: include/linux/spi/spi.h
        drivers/spi/spi.c

```c
//函数原型
#define spi_register_driver(driver) \
    __spi_register_driver(THIS_MODULE, driver)
int __spi_register_driver(struct module *owner, struct spi_driver *sdrv);

//参数
owner：驱动模块的拥有者，固定为THIS_MODULE
sdrv: 驱动加载时，总线需要访问的驱动结构体
返回: 0表示执行成功，其它值表示执行出错

//例程
//设备树
spidev0:icm20608@0 {
    compatible = "rmk,icm20608";
    spi-max-frequency = <8000000>;
    reg = <0>;
};

/* 
用于匹配spi总线下的节点，可通过ls /sys/bus/spi/devices/查看支持的接口
总线匹配成功设备树后创建资源，这里每个设备节点对应spi_device。
匹配属性为compatible
*/
static const struct of_device_id icm20608_of_match[] = {
    { .compatible = "rmk,icm20608" },
    { /* Sentinel */ }
};

static struct spi_driver icm20608_driver = {
    .probe = icm20608_probe,
    .remove = icm20608_remove,
    .driver = {
        .owner = THIS_MODULE,
        .name = "icm20608",
        .of_match_table = icm20608_of_match, 
    },
};
int ret = spi_register_driver(&icm20608_driver);
```

### spi_unregister_driver

- 功能: spi总线移除指定驱动，会调用注册时指定的.remove函数
- 目录: include/linux/spi/spi.h

```c
//函数原型
void spi_unregister_driver(struct spi_driver *driver);

//参数
driver: 驱动移除时，总线需要访问的驱动结构体

//例程
int ret = spi_register_driver(&icm20608_driver);
```

### spi_message_init

- 功能: 初始化spi message消息
- 目录: include/linux/spi/spi.h

```c
//函数原型
static inline void spi_message_init(struct spi_message *m)

//参数
m: 定义初始化的message消息

//例程
struct spi_message m;
spi_message_init(&m);
```

### spi_message_add_tail

- 功能: 在spi message中添加消息包
- 目录: include/linux/spi/spi.h

```c
//函数原型
static inline void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m)

//参数
t: 增加的spi数据实体
m: 已经初始化的message消息

//例程
struct spi_message m;
struct spi_transfer t;
unsigned char txdata[32];
unsigned char rxdata[32];

txdata[0] = reg | 0x80;
t->tx_buf = txdata;
t->rx_buf = rxdata;
t->len = len+1;
spi_message_init(&m);
spi_message_add_tail(&t, &m);
```

### spi_sync

- 功能: 同步传输spi消息
- 目录: include/linux/spi/spi.h

```c
//函数原型
int spi_sync(struct spi_device *spi, struct spi_message *message);

//参数
spi: 选择要进行spi通讯的设备结构
message: 要发送的消息
返回: 0表示通讯成功， 其它表示通讯失败

//例程
struct spi_message m;
struct spi_transfer t;
struct spi_device *spi; //probe时提供的消息
int ret;

"...."
spi_message_init(&m);
spi_message_add_tail(&t, &m);
ret = spi_sync(spi, &m); 
if(!ret)
{
    memcpy(rx_buf, &t->rx_buf[1], t->len-1);
}

/*
spi在发送的同时会进行接收，所以接收的实际长度为rx_req+tx_len
例如发送寄存器地址长度1，实际发送和接收长度都需要为rx_req+1, 
*/
```

### spi_sync_transfer

- 功能: 同步传输spi消息, 消息自带初始化
- 目录: include/linux/spi/spi.h

```c
//函数原型
int spi_sync_transfer(struct spi_device *spi, struct spi_transfer *xfers, unsigned int num_xfers);

//参数
spi: 选择要进行spi通讯的设备结构
xfers: 要发送的数据数组
num_xfer: 要发送的数据数组数目
返回: 0表示通讯成功， 其它表示通讯失败

//例程
struct spi_transfer t[2];
struct spi_device *spi; //probe时提供的消息

t[0]->tx_buf = txdata;
t[0]->rx_buf = rxdata;
t[0]->len = len+1;
t[1]->tx_buf = txdata;
t[1]->rx_buf = rxdata;
t[1]->len = len+1;
spi_sync_transfer(spi, t, ARRAY_SIZE(t));
```

### spi_write_then_read

- 功能: spi封装的读写接口(同步), 用于简化读写操作
- 目录: include/linux/spi/spi.h

```c
//函数原型
int spi_write_then_read(struct spi_device *spi, const void *txbuf, unsigned n_tx, void *rxbuf, unsigned n_rx)

//参数
spi: 选择要进行spi通讯的设备结构
txbuf: 发送数据的首地址
n_tx: 发送数据的长度
rx_buf:接收数据的首地址
n_rx:接收数据的长度
返回: 0表示通讯成功， 其它表示通讯失败

//举例
u8 txbuf[1];
u8 rxbuf[6];
struct spi_device *spi; //probe时提供的消息

int ret = spi_write_then_read(spi, txbuf, 1, rxbuf, 6);
```

## device_create

### register_chrdev

- 功能: spi封装的读写接口(同步), 用于简化读写操作
- 目录: include/linux/spi/spi.h

## devicetree_api

### of_gpio_named_count

- 功能: 获取设备树节点属性中的gpio个数(需要为I/O节点).
- 目录: include/linux/of_gpio.h

```c
//函数原型
inline int of_gpio_named_count(const struct device_node *np, const char *propname);

//参数
np: 设备树节点
propname: 节点内属性名称

//例程说明
ctrl-gpios = <0
        &gpio1 1 2
        0
        &gpio2 3 4>;
int count = of_gpio_named_count(np, "ctrl-gpios");  //返回4
```

## next_chapter

[返回目录](./SUMMARY.md)

直接开始下一节说明: [ch03-01.设备树说明](./ch03-02.char_device.md)
