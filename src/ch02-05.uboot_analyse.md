# U-Boot启动执行分析

本篇主要以I.MX6ULL的"U-Boot 22.04"版本作为基础进行分析，关于如何分析启动流程，主要关注两个部分。

1. 用于定义文件加载的u-boot.lds文件
2. 生成的描述函数和文件位置的u-boot.map文件

## 文件说明



## 启动文件处理

关于启动文件，在

```shell
ENTRY(_start)                                #定义程序的入口地址
SECTIONS
{
    . = 0x00000000;
    . = ALIGN(4);
    .text :
    {
        *(.__image_copy_start)
        *(.vectors)                           #定义系统的中断向量表
        arch/arm/cpu/armv7/start.o (.text*)   #定义系统的启动文件，reset复位入口
    }
    
    #.....
}
```

其中_start为程序的入口地址，位于arch/arm/lib/vectors.S中。vectors.S除了上面的跳转到复位执行入口，还建立了向量表，用于后续中断访问， 具体如下所示。

```c
//start启动入口
_start:
#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG
    .word   CONFIG_SYS_DV_NOR_BOOT_CFG
#endif
    ARM_VECTORS 

//ARM_VECTORS函数
    .macro ARM_VECTORS
#ifdef CONFIG_ARCH_K3
    ldr     pc, _reset
#else
    b   reset //跳转执行reset
#endif

//支持的中断函数
undefined_instruction:
software_interrupt:
prefetch_abort:
data_abort:
not_used:
irq:
fiq:
```

reset地址在arch/arm/cpu/armv7/start.S, 这一步开始正式执行挂那种对，进入SVC32模式，然后，此文件有很多宏未使用，对于不支持的宏内代码不进行说明，执行启动相关的处理完成后，跳转到_main入口，进行下一步初始化动作。

```c
/*
* disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
* except if in HYP mode already
*/
mrs r0, cpsr
and r1, r0, #0x1f       @ mask mode bits
teq r1, #0x1a           @ test for HYP mode
bicne r0, r0, #0x1f     @ clear all mode bits
orrne r0, r0, #0x13     @ set SVC mode
orr r0, r0, #0xc0       @ disable FIQ and IRQ
msr cpsr,r0

//跳转到main入口执行
bl  _main
```

_main地址在arch/arm/lib/crt0.S中，主要完成系统必要的初始化，以及C运行时的支持，具体代码如下。

```c
ENTRY(_main)

/*
 * Set up initial C runtime environment and call board_init_f(0).
 */

    ldr     r0, =(CONFIG_SYS_INIT_SP_ADDR)

    bic     r0, r0, #7     /* 8-byte alignment for ABI compliance */
    mov     sp, r0
    bl     board_init_f_alloc_reserve          //从top地址分配预留地址，通过CONFIG_SYS_MALLOC_F_LEN定义
    mov     sp, r0
    /* set up gd here, outside any C code */
    mov     r9, r0
    bl     board_init_f_init_reserve           //实现内存布局

    mov     r0, #0                     
    bl     board_init_f                        //板级序列初始化接口

/*
 * Set up intermediate environment (new sp and gd) and call
 * relocate_code(addr_moni). Trick here is that we'll return
 * 'here' but relocated.
 */

    ldr     r0, [r9, #GD_START_ADDR_SP]     /* sp = gd->start_addr_sp */
    bic     r0, r0, #7     /* 8-byte alignment for ABI compliance */
    mov     sp, r0
    ldr     r9, [r9, #GD_NEW_GD]          /* r9 <- gd->new_gd */

    adr     lr, here
    ldr     r0, [r9, #GD_RELOC_OFF]          /* r0 = gd->reloc_off */
    add     lr, lr, r0
    ldr     r0, [r9, #GD_RELOCADDR]          /* r0 = gd->relocaddr */
    b     relocate_code

here:

    bl     relocate_vectors

    /* Set up final (full) environment */

    bl     c_runtime_cpu_setup     /* we still call old routine here */

    CLEAR_BSS                       

    bl coloured_LED_init                /* led初始化, __weak未定义 */
    bl red_led_on

    /* call board_init_r(gd_t *id, ulong dest_addr) */
    mov     r0, r9                      /* gd_t */
    ldr     r1, [r9, #GD_RELOCADDR]     /* dest_addr */

    /* call board_init_r */
    ldr     pc, =board_init_r           /* this is auto-relocated! */
```

对于crt0.S中，主要功能函数功能如下。

1. board_init_f_alloc_reserve，board_init_f_init_reserve位于common/init/board_init.c中，主要实现内存排布，计算出top地址，实例化gb指针，并完成初始化。
2. board_init_f位于common/board_f.c中，主要执行初始化序列。
3. relocate_code位于arch/arm/lib/relocate.s

## next_chapter

[返回目录](./SUMMARY.md)

直接开始下一小节: [Linux kernel移植](./ch02-06.kernel_transplate.md)
