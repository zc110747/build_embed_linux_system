# 嵌入式Linux系统bringup

掌握嵌入式soc的bringup流程的是嵌入式从入门到资深的必经之路，也是学习中最复杂困难的部分。如果上一章节对于入门者还可以勉强上手，**那么这一节如果没有基础不要去深入学习**，可以了解有个概念，等有一定基础在过来补足。这部分学习需要很多前置的知识才能够理解，是需要在驱动和应用开发中去掌握的。对于完整的实现芯片的bringup，需要掌握的知识如下所示(包括不限于)。

- Shell脚本编程
- KConfig语法， menuconfig配置
- Makefile语法，make命令
- Linux驱动开发大部分知识，包含芯片硬件模块信息，外设接口，设备树，驱动接口等
- Uboot框架和源码理解
- linux框架和源码理解
- 文件系统的知识理解
- 至少熟练掌握嵌入式C语言开发
- 基于arm交叉编译平台的开发调试能力

## soc_bringup_design

这里从开发的难易程度来说明对soc bringup的个人理解；对于开发来说，从易到难有三个层次。

1. 基于确定芯片开发板或者工业板，移植应用平台的soc bringup。
2. 基于芯片厂商方案进行开发板级适配的soc bringup。
3. 基于uboot和内核的主干，移植适配特定芯片的soc bringup。

### 基于开发平台方案的soc bringup

基于开发平台的soc bringup是大部分产品级开发的时候面对的环境，使用稳定的工业板可以方便快速的开发，大部分情况可以不做修改，即使有新的硬件要求，使用自己的底板，只要在基础上增加或者裁剪相应的外设驱动就可以，需要运行环境如QT，Debain，各类lib库都已经支持，很多时候可以做到保姆级服务，开箱即用，提供编译好的包可以直接烧录即可使用。此时嵌入式的主要工作就是应用开发，做到少量甚至完全不修改驱动。

这类已经可以满足大部分环境的要求，大部分嵌入式linux的工作都是进行少量linux驱动的硬件适配，有稳定平台后，进行产品开发。而且方案商的开发板因为使用人员多，测试充分，对于工业板来说会更加稳定，一般小公司或者大公司内小团队因为没有足够的人员维护一套稳定的嵌入式平台环境，可能还不如方案商的代码稳定，因此这行业很多产品采用这种模式。

### 基于芯片厂商方案的soc bringup

基于芯片厂商方案的soc bringup实现，主要是方案商或培训机构, 以及能够负担专门维护定制化Linux团队的厂商才会这么做。在确定嵌入式芯片后，芯片厂商会提供相应的编译工具，支持维护的uboot和kernel分支，以及基于官方开发板的一套软硬件平台方案。不过这类板子一般功能展示厂商主推的功能，所以I/O暴露较少，作为实际的工业板需要二次软硬件设计。

芯片厂商的方案，通过二次设计并根据硬件维护自己的配置，提供打包的环境和烧录工具给产品开发客户。这类工作主要由方案商，培训机构以及负担平台维护的专业团队完成, 基于芯片厂商提供的已经适配芯片的uboot，kernel和文件系统，裁剪一套自定义编译框架，然后以整机或者方案的模式提供给产品开发者; 内容则主要为硬件接口，设备树的修改，裁剪和配置Uboot和Linux来适配设计的硬件，此外也会移植文件系统如busybox, debain或android，并提供支持上层应用的开发库支持，当然一般也会提供一些例程用于演示。

### 基于系统主干的soc bringup

这部分主要是芯片原厂的工作，需要以某个uboot和linux分支作为基础，增加芯片级的硬件支持，包括不限于存储，寄存器，设备树和硬件驱动接口，特殊模块如GPU，NPU驱动的支持。不过除非全新的模块，大部分也是在原驱动基础上迭代，进行新的功能的支持。这些工作是伴随着芯片存在的整个周期进行开发的，而且同一系列的芯片也会有继承，这也是芯片原厂中嵌入式开发主要的工作之一。 对于大部分嵌入式linux开发者来是接触不到的。从技术上需要对芯片内核，设计框架，驱动，Uboot，Linux内核都要有深入认知。这部分国外的芯片厂商如NXP，TI做的比较好，官网都会提供相应的资料，即使个人用户也很方便去查找使用，国内厂商则基本只对商业用户服务，客观上是人为设置壁垒，对于芯片的推广也是不利的。

综上可知，如果是希望往嵌入式Linux驱动方向发展，那么达到第二种水平就是必须的，第三种则看能否去原厂的机会在提高。如果从事嵌入式linux应用开发，只要满足第一种水平，能够简单的修改驱动能满足大部分的场景，一般能够在开发板基础上完成uboot，linux和文件系统的编译，完成大部分外设的修改，就算入门了，如果增加新的器件，如RS485, 摄像头，i2c接口的温度传感器，I/O扩展芯片，SPI扩展屏也能够实现驱动并正常工作，且能解决遇到的软硬件配合问题，那么已经可以应对大部分应用开发遇到的问题，下面则分别展示基于平台和芯片厂商方案的bringup，至于芯片级的bringup，因为我本人水平有限，如果未来有机会深入学习，在进行补足。

## 嵌入式linux系统启动流程

嵌入式Linux系统的启动流程大致可以分为引导程序加载(bootloader), 内核加载，然后根据用户和系统类型，进入图形界面或者命令行模式，根据上述信息，具体流程如下。

- 硬件初始化和自检，由引导加载程序(bootloader)完成必要硬件的初始化，如SDRAM，NAND，EMMC，ETH，LCD等，并完成相应的自检动作。
- 加载内核和设备树，由bootloader将内核和设备树加载到指定的内存地址，然后跳转执行内核启动流程。
- 内核初始化，内核加载后，开始进行初始化动作，包含总线和硬件设备驱动的启动，当内核完成硬件驱动的启动后，就开始加载文件系统。
- 文件系统服务运行，在文件系统执行后，会先访问/etc/inittab中的设置，开始顺序执行文件系统内的程序，脚本和服务，提供命令行或者图形化的服务。

基于上述流程，就可以简化成uboot启动，内核加载，文件系统运行，最后提供可执行用户应用的Linux环境，无论是简单的busybox环境，还是复杂的debain系统(ubuntu), 其实原理上都是一致的，了解了这一点，对于nand，emmc，sdcard和网络启动就比较好理解了。这里面bootloader的加载是由芯片内部的rom程序完成的，根据相应的启动选项(由I/O控制启动方法），可以完成从存储中加载bootloader并执行第一步，之后就可以由bootloader管理进一步的加载地址，从而实现从不同存储地址加载到内存中，并跳转执行，了解了这个流程，对于系统的bringup，也就是按照相同的流程去调试。

- uboot的移植和调试
- kernel的移植和调试
- rootfs文件系统的构建

这也是我们实现bringup的全流程，如果有一定的基础，是可以直接开始学习，如果是新手，建议掌握Makefile，KConfig以及大部分驱动开发的知识再去尝试，这是嵌入式Linux中比较困难的部分，即使上手发现不会也不要气馁，先从驱动和应用去学习，回过头来，掌握这部分会事半功倍。

## next_chapter

[返回目录](./SUMMARY.md)

直接开始下一小节:[ch02-01.Makefile脚本语法](./ch02-01.makefile.md)。
