# 嵌入式Linux系统启动实现

在上一章节中，讲述了如何安装虚拟机平台，修改软件源，安装常用软件应用并讲述了一些交叉编译的功能实现。从本节开始，就需要将上述知识应用到真正的嵌入式设备上，让芯片运行起来，构建后续驱动开发和应用的平台。如果上一章节对于入门者还可以勉强上手，**那么这一章节如果没有基础不要去深入学习**，这部分学习需要很多前置的知识才能够理解，因此遇到不理解的地方可以带着问题直接跳过去进行后续的学习，这并不是逃避，而是我在实践中总结的方法。对于本节的学习，需要掌握如下知识。

- Shell脚本编程
- KConfig语法， menuconfig配置
- Makefile语法，make命令
- Linux驱动开发技术，包含芯片硬件模块信息，外设接口，设备树，驱动接口等
- Uboot框架和源码理解
- Linux框架和源码理解
- 文件系统的知识理解
- 至少熟练掌握嵌入式C语言开发
- 基于arm交叉编译平台的开发调试能力

目前能够运行嵌入式Linux系统的平台主流都是基于Cortex-A的多核平台，属于复杂的soc系统，因此像单片机一样由用户直接从启动的入口函数去开发是不现实的。不过幸运的是由这个世界上最具有分享精神，也技术力十分强大的一批技术人员维护了由U-boot, Linux, Rootfs构成的框架来完成对于上述平台的支持，让我们可以更轻松的构建嵌入式Linux应用，这三部分的功能和说明如下所示.

U-Boot(Universal BootLoader)开源引导加载程序，类似PC端的BIOS引导，在启动时开始加载，主要包含功能如下。

- 启动加载，从不同的存储介质加载和启动操作系统(emmc，nand，网络，sdcard等)，
- 系统配置，配置系统的工作频率，内存和设备接口，设置环境变量等
- 网络服务和系统更新，可通过网络下载和启动内核，支持多种协议，并支持命令更新到具体的存储介质中
- 硬件管理，支持具体的硬件功能操作，如开机UI显示，设备自检等功能

一般来说，U-Boot支持一系列命令用于修改环境变量，操作存储介质并提供网络服务。当U-Boot引导加载内核完毕后，即跳转开始Linux Kernel的执行。

Linux内核是Linux操作系统的核心组件，负责管理系统的硬件和软件资源，为应用程序提供服务。主要包含功能如下。

- 系统初始化和硬件驱动管理，负责硬件的设备的初始化工作，加载并管理硬件的驱动。
- 内存管理，负责管理系统的内存资源，包含物理内存和虚拟内存，实现了分页机制，根据需要进行映射和管理。
- 系统接口调用和进程管理，提供系统调用接口和进程服务，并支持进程通讯机制(IPC),如信号量，管道和匿名管道等。
- 文件系统，支持多种文件系统(ext4, zfs等)，并提供统一的文件和目录的访问接口。
- 网络管理：内核负责处理网络协议和数据传输。支持TCP/IP协议栈，可以通过socket接口访问。
- 安全和权限管理：内核提供了安全机制，如访问控制列表（ACL）和强制访问控制（SELinux）等，以保护系统免受未经授权的访问和攻击。
- 电源管理：内核负责处理系统的电源管理功能，如休眠、待机和关机等。

Linux提供上述功能和接口用于具体应用的开发，表现在具体的应用中，就以文件的方式提供；文件和操作访问这些文件的命令和库的集合就是我们常提到的rootfs(文件系统)，简单来说，文件系统就是目录的合集，里面包含两部分。

- Linux内核中设备，文件接口的映射，这部分其实比较简单，只要在文件系统中存在目录，内核加载文件系统时会挂载相应的设备文件，并在指定的目录下根据文件类型创建相应的目录结构，主要位于/dev, /proc, /sys目录下。
- 访问的工具集，服务脚本以及库文件。其中除基础的shell和shell运行需要的环境，以及启动的必要服务外，其它都是为了方便我们进行操作或者开发才需要安装的文件，例如/bin/，/usr/bin/目录下的命令和/lib/,/usr/lib/下的库。
- 系统启动时需要的配置，脚本和服务，主要位于/etc, /home, /root目录下。

无论是busybox，buildroot， yocto，debain还有ubuntu，都是提供上述功能，本质上并没有什么区别。

1. 创建文件系统需要的目录，如bin，lib，tmp，usr，etc, dev, root, home等。
2. 安装系统执行需要的命令，如bash shell，tar, gzip等。
3. 安装程序运行需要的库，一般是编译时调用的gcc中的lib库，以及一些软件执行需要的库。
4. 添加启动和配置文件或服务，加载一系列命令完成调用。

完成上述步骤，就从U-Boot启动，内核加载和执行，文件系统加载和系统服务执行，获得能够访问和运行的系统平台。

## soc_bringup_design

对于构建Linux启动运行的平台，从易到难有三个层次。

- 基于确定芯片开发板或者工业板，移植应用平台的soc启动。
- 基于芯片厂商方案进行开发板级适配的soc启动。
- 基于uboot和内核的主干，移植适配特定芯片的soc启动。

### 基于开发平台方案的芯片启动

基于开发平台的芯片启动是大部分产品级开发面对的环境，使用稳定的工业原型板可以方便快速的开发，大部分情况都可以不做修改直接进行开发。即使有新的硬件要求，也只是在基础上增加或者裁剪相应的外设驱动就可以，需要运行环境如QT，Debain等。这种情况下各类lib库都已经支持，很多时候都是提供编译好的包做到开箱即用。嵌入式的主要工作就是应用开发，做到少量甚至完全不修改驱动。

这类已经可以满足大部分场景的要求，大部分嵌入式Linux的工作都是进行少量硬件适配。理论上方案商的开发板使用人员多，测试往往更加充分，对于工业板来说会更加稳定。一般小公司或者大公司内小团队如果没有足够的人员维护稳定的嵌入式Linux环境，可能还不如方案商的代码稳定，这也是很多产品直接采用方案商的平台进行开发的原因。

### 基于芯片厂商方案的芯片启动

基于芯片厂商方案的芯片启动实现，这类工作主要是方案商或培训机构, 以及能够负担专门维护定制化Linux团队的厂商才会这么做。在确定嵌入式芯片后，芯片厂商会提供相应的编译工具，支持维护的uboot和kernel分支，以及基于官方开发板进行更改的软硬件平台方案。因为官方开发板一般只展示厂商主推的功能，I/O暴露较少，作为应用平台一般需要二次的软硬件设计。

方案商的主要工作，就是基于芯片厂商的方案，二次设计硬件，并维护自己的配置，提供打包的环境和烧录工具的资源包。基于芯片厂商提供的已经适配芯片的uboot，kernel和文件系统，裁剪和修改维护一套SDK资源包，然后以整机或方案的模式提供开发者; 这部分主要工作内容包含如下。

- 基于官方例程构建一套运行平台，一般包含Linux虚拟机，交叉编译工具，U-Boot,Linux Kernel,文件系统源码和打包文件。
- 设备树的修改和驱动的更新用于适配设计的硬件。
- 移植文件系统如busybox, debain或android，并提供支持上层应用的开发库支持。
- 具体的产品方案和文档服务，一般都是demo方案，很少涉及产品级的具体应用(除非定制化的需求)。

### 基于系统主干的芯片启动

系统主干到芯片的适配是由芯片原厂完成，需要以某个版本的Uboot和Linux发布主干为基础，增加芯片级的硬件支持，包括不限于存储，寄存器，设备树和硬件驱动接口，特殊模块如GPU，NPU驱动的支持。不过除非全新的模块，大部分也是在原驱动基础上迭代，进行新的功能的支持。这些工作是伴随着芯片存在的整个周期进行的，而且同一系列的芯片也会有继承，这也是芯片原厂中嵌入式开发主要的工作之一，对于大部分嵌入式Linux开发者来说是接触不到的。从技术上需要对芯片内核，设计框架，驱动，uboot，Linux内核都要有深入认知。这部分**国外的芯片厂商如NXP，TI做的比较好，官网都会提供全套的资料，即使个人用户也很方便去查找使用，国内厂商则基本只对商业用户开放，客观上是人为设置壁垒，对于芯片的推广也是不利的，除非价格差异大，学习阶段建议选择资料更全的芯片**。

综上可知，如果是希望往嵌入式Linux驱动方向发展，那么达到第二种水平就是必须的，第三种则看能否去原厂的机会在提高。如果从事嵌入式Linux应用开发，只要满足第一种水平，能够在原型板基础上完成Uboot，Linux和文件系统的编译，进行部分外设的修改，就算入门了，如果增加新的器件，如RS485, 摄像头，i2c接口的温度传感器，I/O扩展芯片，SPI扩展屏也能够实现驱动并正常工作，在遇到的软硬件问题能够有思路并解决，那么已经可以应对大部分产品开发遇到的问题。

下面则分别展示基于平台和芯片厂商方案的bringup，至于芯片级的bringup，因为我本人水平有限，如果未来有机会深入学习，在进行补足。

## 嵌入式linux系统启动流程

嵌入式Linux系统的启动流程大致可以分为引导程序加载(bootloader), 内核加载，然后根据用户和系统类型，进入图形界面或者命令行模式，根据上述信息，具体流程如下。

- 硬件初始化和自检，由引导加载程序(bootloader)完成必要硬件的初始化，如SDRAM，NAND，EMMC，ETH，LCD等，并完成相应的自检动作。
- 加载内核和设备树，由bootloader将内核和设备树加载到指定的内存地址，然后跳转执行内核启动流程。
- 内核初始化，内核加载后，开始进行初始化动作，包含总线和硬件设备驱动的启动，当内核完成硬件驱动的启动后，就开始加载文件系统。
- 文件系统服务运行，在文件系统执行后，会先访问/etc/inittab中的设置，开始顺序执行文件系统内的程序，脚本和服务，提供命令行或者图形化的服务。

基于上述流程，就可以简化成uboot启动，内核加载，文件系统运行，最后提供可执行用户应用的Linux环境，无论是简单的busybox环境，还是复杂的debain系统(Ubuntu), 其实原理上都是一致的，了解了这一点，对于nand，emmc，sdcard和网络启动就比较好理解了。这里面bootloader的加载是由芯片内部的rom程序完成的，根据相应的启动选项(由I/O控制启动方法），可以完成从存储中加载bootloader并执行第一步，之后就可以由bootloader管理进一步的加载地址，从而实现从不同存储地址加载到内存中，并跳转执行，了解了这个流程，对于系统的bringup，也就是按照相同的流程去调试。

- Uboot的移植和调试
- kernel的移植和调试
- rootfs文件系统的构建

这也是我们实现启动的全流程，如果有一定的基础，是可以直接开始学习，如果是新手，建议掌握Makefile，KConfig以及大部分驱动开发的知识再去尝试，这是嵌入式Linux中比较困难的部分，即使上手发现不会也不要气馁，先从驱动和应用去学习，回过头来，掌握这部分会事半功倍。

## next_chapter

[返回目录](./SUMMARY.md)

直接开始下一小节:[ch02-01.Makefile脚本语法](./ch02-01.makefile.md)。
