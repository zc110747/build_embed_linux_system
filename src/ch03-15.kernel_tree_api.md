# 驱动设备树接口

设备树一般配合统一驱动模型使用，很多情况下使用总线接口的接口访问(如platform，i2c, spi)，不过对于设备树本身也支持访问的接口，在本节将会详细列出。

- [dts_node_api](#dts_node_api)
  - [of_find_node_by_path](#of_find_node_by_path)
  - [of_find_node_opts_by_path](#of_find_node_opts_by_path)
  - [of_find_node_by_name](#of_find_node_by_name)
  - [of_find_node_by_type](#of_find_node_by_type)
  - [of_find_compatible_node](#of_find_compatible_node)
  - [of_find_matching_node_and_match](#of_find_matching_node_and_match)
  - [of_find_node_by_phandle](#of_find_node_by_phandle)
  - [of_find_node_with_property](#of_find_node_with_property)
  - [of_get_parent](#of_get_parent)
- [of_property_api](#of_property_api)
  - [of_find_property](#of_find_property)
  - [of_property_count_elems_of_size](#of_property_count_elems_of_size)
  - [of_property_read_xx_index](#of_property_read_xx_index)
  - [of_property_read_xx_array](#of_property_read_xx_array)
  - [of_property_read_string](#of_property_read_string)
  - [of_property_read_string_index](#of_property_read_string_index)
  - [of_property_read_string_array](#of_property_read_string_array)
  - [of_property_match_string](#of_property_match_string)
  - [of_property_count_strings](#of_property_count_strings)
  - [of_property_read_bool](#of_property_read_bool)
  - [of_n_xx_cells](#of_n_xx_cells)
- [of_feature_api](#of_feature_api)、
  - [of_get_property](#of_get_property)
  - [of_device_is_compatible](#of_device_is_compatible)
  - [of_device_compatible_match](#of_device_compatible_match)
  - [of_device_is_available](#of_device_is_available)
  - [of_get_child_count](#of_get_child_count)
  - [of_get_available_child_count](#of_get_available_child_count)
  - [of_get_address](#of_get_address)
  - [of_address_to_resource](#of_address_to_resource)
  - [of_iomap](#of_iomap)
  - [of_clk_get_parent_count](#of_clk_get_parent_count)
  - [of_clk_get_parent_name](#of_clk_get_parent_name)

## dts_node_api

### of_find_node_by_path

- 功能: 根据设备树中路径获取设备树节点信息
- 目录: include/linux/of.h

```c
//函数原型
struct device_node *of_find_node_by_path(const char* path)

//参数
path: 在设备树的绝对地址，或者设备节点的别名(alias定义)
返回: 设备树节点结构体

//例程
struct device_node *node0 = of_find_node_by_path("/foo/bar"); //full path
struct device_node *node1 = of_find_node_by_path("foo");      //valid alias
struct device_node *node2 = of_find_node_by_path("foo/bar");  //valid alias + relative path
```

### of_find_node_opts_by_path

- 功能: 根据设备树中路径获取设备树节点信息
- 目录: drivers/of/base.c

```c
//函数原型
struct device_node *of_find_node_opts_by_path(const char* path, const char **opts)

//参数
path: 在设备树的绝对地址，或者设备节点的别名(alias定义)
opts: 获取地址中以:分隔的字符串首地址
返回: 设备树节点结构体

//例程
struct device_node *node0 = of_find_node_by_path("/foo/bar", NULL); //full path
```

### of_find_node_by_name

- 功能: 根据节点的name属性在指定节点下获取设备节点
- 目录: drivers/of/base.c

```c
//函数原型
struct device_node *of_find_node_by_name(struct device_node *from, const char *name)

//参数
from: 用于查找的设备节点，NULL表示从根节点查找整个设备树
name: 查找节点的name属性内容
返回: 设备树节点结构体

//例程
struct device_node *volt_gpio_np;
volt_gpio_np = of_find_node_by_name(NULL, "cpu-vcore-select");
```

### of_find_node_by_type

- 功能: 根据节点的type属性在指定节点下获取设备节点
- 目录: drivers/of/base.c

```c
//函数原型
struct device_node *of_find_node_by_type(struct device_node* from, const char* type)

//参数
from: 用于查找的设备节点，NULL表示从根节点查找整个设备树
type: 查找节点的device_type属性内容
返回: 设备树节点结构体

//例程
struct device_node *np;
np = of_find_node_by_type(NULL, "cpu");
```

### of_find_compatible_node

- 功能: 根据节点的type和compatible属性获取设备节点
- 目录: drivers/of/base.c

```c
//函数原型
struct device_node *of_find_compatible_node(struct device_node* from, const char *type, const char* compat)

//参数
from: 用于查找的设备节点，NULL表示从根节点查找整个设备树
type: 查找节点的device_type属性内容， NULL则不检查
compat: 查找匹配的compatible内容
返回: 设备树节点结构体

//例程
struct device_node *np;
np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-anatop");
```

### of_find_matching_node_and_match

- 功能: 根据of_device_id匹配表格查找匹配的设备节点
- 目录: drivers/of/base.c

```c
//函数原型
struct device_node *of_find_matching_node_and_match(struct device_node *from,
                                                    const struct of_device_id *matches,
                                                    const struct of_device_id **match)

//参数
from: 用于查找的设备节点，NULL表示从根节点查找整个设备树
matches: 查找的of_device_id表格
match：匹配的设备树表格
返回: 设备树节点结构体

//例程
static const struct of_device_id versatile_clcd_of_match[] = {
    {
        .compatible = "arm,core-module-integrator",
        .data = (void *)INTEGRATOR_CLCD_CM,
    },
    {
        .compatible = "arm,versatile-sysreg",
        .data = (void *)VERSATILE_CLCD,
    },
};
struct device_node *np;
const struct of_device_id *clcd_id;
np = of_find_matching_node_and_match(NULL, versatile_clcd_of_match,
    &clcd_id);
```

### of_find_node_by_phandle

- 功能: 根据节点句柄查找设备节点
- 目录: drivers/of/base.c

```c
//函数原型
typedef u32 phandle;
struct device_node *of_find_node_by_phandle(phandle handle)

//参数
phandle: 设备节点的句柄
返回: 获取当前的设备节点

//例程
//读取csi-mux-mipi内容属性
ret = of_property_read_u32_array(np, "csi-mux-mipi", out_val, 3);
if (ret) {
    dev_dbg(csi_dev->dev, "no csi-mux-mipi property found\n");
} else {
    phandle = *out_val;
    node = of_find_node_by_phandle(phandle);
}
```

### of_find_node_with_property

- 功能: 查询具有指定属性的设备节点
- 目录: drivers/of/base.c

```c
//函数原型
struct device_node *of_find_node_with_property(struct device_node *from,
    const char *prop_name)

//参数
from: 用于查找的设备节点，NULL表示从根节点查找整个设备树
prop_name: 指定节点属性的名称
返回: 设备树节点结构体

//例程
struct device_node *controller = NULL;
controller = of_find_node_with_property(controller, "phys");
```

### of_get_parent

- 功能: 获取当前节点的父节点
- 目录: drivers/of/base.c

```c
//函数原型
struct device_node *of_get_parent(const struct device_node *node)

//参数
node: 当前定义的设备节点
返回: 当前设备节点的父节点

//例程
struct device_node *firmware_node;
firmware_node = of_get_parent(dev->of_node);
```

## of_property_api

### of_find_property

- 功能: 根据节点和属性名称获取节点具体属性结构
- 目录: drivers/of/base.c

```c
//函数原型
struct property *of_find_property(const struct device_node *np, const char *name, int *lenp)

//参数
np: 当前定义的设备节点
name: 需要获取属性的节点名
lenp: 返回属性内容的对应个数，NULL表示不需要返回
返回: 获取的属性内容结构体

//例程
struct device_node *np = pdev->dev.of_node;
struct property *proper = of_find_property(np, "compatible", NULL);
if(proper == NULL) {
    dbg_err(&pdev->dev, "property find failed\n");
} else {
    dbg_info(&pdev->dev, "compatible = %s\n", (char*)proper->value);
}
```

### of_property_count_elems_of_size

- 功能: 根据设备节点，属性名称以及元素长度获取内部元素个数
- 目录: drivers/of/property.c

```c
//函数原型
int of_property_count_elems_of_size(const struct device_node *np,
                const char *propname, int elem_size);

//参数
np: 当前选择的设备节点
propname: 需要统计的元素属性
elem_size: 属性中单个元素的长度
返回: 属性内部元素的个数

//例程
struct device_node *aff；
int n;
n = of_property_count_elems_of_size(aff, "cpus", sizeof(u32));
if (WARN_ON(n < 0))
    return;
```

### of_property_read_xx_index

- 功能: 根据设备节点，属性名称以及元素得位置获取具体值(32位或64位)
- 目录: drivers/of/property.c

```c
//函数原型
int of_property_read_u32_index(const struct device_node *np,
                        const char *propname,
                        u32 index, u32 *out_value)
int of_property_read_u64_index(const struct device_node *np,
                        const char *propname,
                        u32 index, u64 *out_value)

//参数
np: 当前选择的设备节点
propname: 当前选择的属性值
index: 属性内部值得编号
out_value: 返回得具体得值，分别代表32位和64位值
返回: 0表示读取成功，其它表示读取失败

//例程
//设备树
gpc: interrupt-controller@20dc000 {
    compatible = "fsl,imx6sll-gpc", "fsl,imx6q-gpc";
    reg = <0x020dc000 0x4000>;
    interrupt-controller;
    #interrupt-cells = <3>;
    interrupts = <0 89 4>;
    interrupt-parent = <&intc>;
    fsl,mf-mix-wakeup-irq = <0x7c00000 0x7d00 0x0 0x1400640>;
};
static u32 gpc_mf_irqs[4];
struct device_node *node;

of_property_read_u32_index(node, "fsl,mf-mix-wakeup-irq", 0,
    &gpc_mf_irqs[0]);
of_property_read_u32_index(node, "fsl,mf-mix-wakeup-irq", 1,
    &gpc_mf_irqs[1]);
of_property_read_u32_index(node, "fsl,mf-mix-wakeup-irq", 2,
    &gpc_mf_irqs[2]);
of_property_read_u32_index(node, "fsl,mf-mix-wakeup-irq", 3,
    &gpc_mf_irqs[3]);
```

### of_property_read_xx_array

- 功能: 根据设备节点，属性名称以及元素得位置获取具体值(32位或64位)
- 目录: drivers/of/property.c

```c
//函数原型
int of_property_read_u8_array(const struct device_node *np,
                        const char *propname,
                        u8 *out_values, size_t sz)
int of_property_read_u16_array(const struct device_node *np,
                        const char *propname,
                        u16 *out_values, size_t sz)
int of_property_read_u32_array(const struct device_node *np,
                        const char *propname,
                        u32 *out_values, size_t sz)
int of_property_read_u64_array(const struct device_node *np,
                        const char *propname,
                        u64 *out_values, size_t sz)
                    
//参数
np: 当前选择的设备节点
propname: 当前选择的属性值
out_values: 读取到得数组值
sz: 读取得数组元素数量
返回: 0表示读取成功，其它表示读取失败

//例程
//设备树
&sata {
    status = "okay";
    /* SATA OOB timing settings */
    ceva,p0-cominit-params = /bits/ 8 <0x18 0x40 0x18 0x28>;
    ceva,p0-comwake-params = /bits/ 8 <0x06 0x14 0x08 0x0E>;
    ceva,p0-burst-params = /bits/ 8 <0x13 0x08 0x4A 0x06>;
    ceva,p0-retry-params = /bits/ 16 <0x96A4 0x3FFC>;
    ceva,p1-cominit-params = /bits/ 8 <0x18 0x40 0x18 0x28>;
    ceva,p1-comwake-params = /bits/ 8 <0x06 0x14 0x08 0x0E>;
    ceva,p1-burst-params = /bits/ 8 <0x13 0x08 0x4A 0x06>;
    ceva,p1-retry-params = /bits/ 16 <0x96A4 0x3FFC>;
    phy-names = "sata-phy";
    phys = <&psgtr 3 PHY_TYPE_SATA 1 1>;
};

//代码
#define NR_PORTS    2
struct ceva_ahci_priv {
    struct platform_device *ahci_pdev;
    /* Port Phy2Cfg Register */
    u32 pp2c[NR_PORTS];
    u32 pp3c[NR_PORTS];
    u32 pp4c[NR_PORTS];
    u32 pp5c[NR_PORTS];
    /* Axi Cache Control Register */
    u32 axicc;
    bool is_cci_enabled;
    int flags;
    struct reset_control *rst;
};

if (of_property_read_u8_array(np, "ceva,p0-cominit-params",
                (u8 *)&cevapriv->pp2c[0], 4) < 0) {
    dev_warn(dev, "ceva,p0-cominit-params property not defined\n");
    return -EINVAL;
}
if (of_property_read_u8_array(np, "ceva,p1-cominit-params",
                (u8 *)&cevapriv->pp2c[1], 4) < 0) {
    dev_warn(dev, "ceva,p1-cominit-params property not defined\n");
    return -EINVAL;
}
if (of_property_read_u16_array(np, "ceva,p0-retry-params",
                (u16 *)&cevapriv->pp5c[0], 2) < 0) {
    dev_warn(dev, "ceva,p0-retry-params property not defined\n");
    return -EINVAL;
}
```

### of_property_read_string

### of_property_read_string_index

### of_property_read_string_array

### of_property_match_string

### of_property_count_strings

### of_property_read_bool

### of_n_xx_cells

of_n_addr_cells
of_n_size_cells

## of_feature_api

### of_get_property

- 功能: 根据节点和属性名称获取节点属性中的内容
- 目录: drivers/of/base.c

```c
//函数原型
const void *of_get_property(const struct device_node *np, const char *name,
            int *lenp)

//参数
np: 当前定义的设备节点
name: 需要获取属性的节点名
lenp: 返回属性内容的对应个数，NULL表示不需要返回
返回: 获取的属性内容，property->value对象

//例程
const char *enable_method;
enable_method = of_get_property(dn, "enable-method", NULL);
```

### of_device_is_compatible

### of_device_compatible_match

### of_device_is_available

### of_get_child_count

### of_get_available_child_count

### of_get_address

### of_address_to_resource

### of_iomap

### of_clk_get_parent_name

### of_clk_get_parent_count

## next_chapter

[返回目录](./SUMMARY.md)

直接开始下一节说明: [驱动基础devm接口](./ch03-16.kernel_devm_base_api.md)

