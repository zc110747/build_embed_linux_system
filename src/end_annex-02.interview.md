# 附录二：Linux面试题整理

学习嵌入式Linux，肯定是为了找工作或者解决工作中的难题，这里整理一些Linux面试题，有网络上收集的，也有自己在面试或者工作中遇到的问题。

- [Linux驱动问题整理](#linux-driver)
  - [Linux设备驱动分类，阐述它们的区别，并分别列举一些实际设备](#interview-01-001)
  - [Linux中引入模块机制的好处](#interview-01-002)
  - [说明驱动模块的操作有哪些命令，加载和移除对应驱动中的接口](#interview-01-003)
  - [查看驱动打印信息的命令，如何查看内核中已注册的字符设备和中断号](#interview-01-004)
  - [字符型驱动设备创建设备文件的方法](#interview-01-005)
  - [简述主设备号和次设备号的用途。执行mknod chardev c 4 46，请分析使用的是那一类设备驱动程序](#interview-01-006)
  - [驱动注册字符设备的相关函数和接口说明](#interview-01-007)
  - [简述copy_to_user和copy_from_user主要功能，一般用于file_operations结构的哪些函数](#interview-01-008)
  - [简述设备驱动模型构成，platform总线的匹配规则，注册驱动和注册设备需要先后顺序吗](#interview-01-009)
  - [简述下Linux中断机制，注册和注销中断的相关函数。中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动](#interview-01-010)
  - [IRQ(Interrupt Request)和FIQ(Fast Interrupt Request)在CPU实现中有什么区别](#interview-01-011)
  - [中断的为啥分上半部分和下半部分，讲下如何实现](#interview-01-012)
  - [linux内核里面，内存申请相关的函数，功能和区别说明](#interview-01-013)
  - [驱动使用什么函数接口访问绝对物理地址，为什么需要](#interview-01-014)
  - [在u-boot烧录进去后，上电后串口上没有任何输出，硬件和软件各应该去检查什么？](#interview-01-015)
  - [描述下Linux系统的启动流程，有没有优化过启动流程的经历，有说明下步骤，没有则按照经验描述下](#interview-01-016)
  - [有没有修改过系统启动中的Logo，实现过开机进度条，简述下实现方法](#interview-01-017)
  - [是否进行过u-boot和内核的适配，主要进行了哪些工作](#interview-01-018)
  - [什么是内存屏障，常见的内存屏障有哪些，应用场景是什么](#interview-01-019)
- [Linux应用操作整理](#linux-app)
  - [堆和栈的分别是什么，它们的操作效率上谁更快](#interview-02-001)
  - [常见的内存分配方式有哪些](#interview-02-002)
  - [linux应用中的同步机制有哪些](#interview-02-003)
  - [linux应用进程间通讯机制](#interview-02-004)
  - [简述下进程，线程和协程的定义](#interview-02-005)
  - [简述下并发和并行](#interview-02-006)
  - [讲解下堵塞和非堵塞，同步和异步的区别](#interview-02-007)
  - [Linux系统的任务调度的算法有哪些](#interview-02-008)
  - [C++程序生成可执行文件的步骤有哪些](#interview-02-009)
  - [什么是静态链接和动态链接。如何生成静态链接库和动态链接库](#interview-02-010)
  - [虚拟内存的目的包含哪些方面](#interview-02-011)
  - [linux进程中止的方法](#interview-02-012)
  - [描述下Linux页面置换算法](#interview-02-013)
  - [内存碎片产生的原因，如何避免内存碎片](#interview-02-014)
  - [什么是守护进程，守护进程如何创建的](#interview-02-015)
  - [什么是僵尸进程和孤儿进程，讲述下产生原因，以及解决办法](#interview-02-016)

## linux-driver

### interview-01-001

Linux设备驱动分类，阐述它们的区别，并分别列举一些实际设备。

1. Linux主要的设备包含字符设备，块设备和网络设备
2. 字符设备以字节为单位进行数据传输，顺序访问，通常没有缓冲区，常用的字符流设备有按键，LED灯，串口，鼠标等
3. 块设备以数据块为单位进行数据传输，随机访问，通常有缓冲区，可以进行文件系统的挂载，常用的块流设备有U盘，SD卡，EMMC，固态硬盘等
4. 网络设备不直接对应文件系统中的文件，基于网络协议(TCP/IP，蓝牙，CAN等)，通常不支持随机访问，常用的网络设备有网卡，WIFI模组，蓝牙模组，CAN等

### interview-01-002

Linux中引入模块机制的好处。

1. 动态扩展内核功能，模块机制允许开发者在不需要重新编译整个内核的情况下，动态地向内核添加或移除功能
2. 优化内核大小，通过模块机制，Linux内核可以实现最小化，即内核中只包含一些基本功能，如模块管理、内存管理等
3. 便于开发和调试，模块机制使得开发者可以独立地开发和调试各个功能模块，而不会影响到整个内核的稳定性
4. 提高系统稳定性，由于模块机制允许在运行时动态加载和卸载功能模块，因此可以在不重启系统的情况下修复或更新内核中的某些功能模块。这有助于提高系统的稳定性，减少因内核更新而导致的系统停机时间

### interview-01-003

说明驱动模块的操作有哪些命令，加载和移除对应驱动中的接口。

驱动加载和移除的命令包含如下。

1. insmod，加载模块，执行驱动中的module_init指定的函数
2. rmmod，移除模块，执行驱动中的module_exit指定的函数
3. lsmod，查看系统已经加载的模块
4. depmod，扫描/lib/modules下的所有模块文件，会在/lib/modules/$(uname -r)目录下生成模块依赖关系
5. modprobe，提供了加载、卸载和查询内核模块的功能，根据生成的模块依赖关系，加载和移除相应的模块

### interview-01-004

查看驱动打印信息的命令，如何查看内核中已注册的字符设备和中断号。

1. 查看驱动模块打印信息使用dmesg命令，配合grep可以查询指定的驱动打印信息，当然也可以修改"/proc/sys/kernel/printk"打印所有信息查看
2. 通过"cat /proc/deivces"查看内核已注册的字符设备
3. 通过"cat /proc/interrupts"查看正在使用的中断号

### interview-01-005

字符型驱动设备创建设备文件的方法。

1. 使用mknod手动创建设备文件，mknod  <设备文件名>  <设备类型>  <主设备号>  <子设备号>，举例：mknod  /dev/chardev  c  4  46
2. 在内核中使用class_create来创建设备类，然后通过device_create创建设备，关联到已经注册字符设备的设备号

### interview-01-006

简述主设备号和次设备号的用途。执行mknod chardev c 4 46，请分析使用的是那一类设备驱动程序。

1. 主设备号用于区分不同种类的设备，次设备号用于区分同一个类型的多个设备
2. 常见字符设备主设备号代表类型， 1-内存设备，4-串口tty设备，5-console设备，10-杂项设备，13-输入设备，因此chartest主设备号为4，表示串口tty设备

### interview-01-007

驱动注册字符设备的相关函数和接口说明。

注册字符设备的相关函数包含如下。

```c
//根据范围注册申请一组设备号(from为起始的主从设备号)，仅申请设备号，设备后续创建
int register_chrdev_region(dev_t from, unsigned count, const char *name);

//动态申请一组设备号值
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)

//初始化字符型设备结构体
void cdev_init(struct cdev *cdev, const struct file_operations *fops)
- cdev: 字符设备结构体
- fops: 设备支持的访问接口结构体

//将申请设备号和字符型设备功能结构在内核中添加并绑定
int cdev_add(struct cdev *p, dev_t dev, unsigned count)
- p: 字符设备结构体
- dev: 关联设备号
- count: 添加内核的设备数目，用于分配连续的次设备号
```

### interview-01-008

简述copy_to_user和copy_from_user主要功能，一般用于file_operations结构的哪些函数。

1. copy_to_user和copy_from_user是Linux内核中的关键函数，它们主要用于在用户空间和内核空间之间安全地传输数据，其中copy_to_user用于用于将数据从内核空间复制到用户空间，copy_from_user函数用于将数据从用户空间复制到内核空间。
2. file_operation中的ioctl，read, write函数会用到这两个函数，用于实现应用层和内核之间的数据交互。

### interview-01-009

简述设备驱动模型构成，platform总线的匹配规则，注册驱动和注册设备需要先后顺序吗？

1. 设备驱动模型由总线，设备，驱动三部分组成
2. Platform总线是Linux内核中用于管理不直接挂接在物理总线上的设备（如LED、LCD、RTC等）的一种虚拟总线，其主要匹配支持platform访问的节点(一般为根节点，或者在其compatible属性中包含"simple-bus", "simple-mfd", "isa", "arm,amba-bus"节点的子节点)，与可访问设备字节中的compatible属性字符串匹配则加载驱动。
3. 对于片上设备和大部分板级设备，都是需要先注册设备，再注册驱动。部分支持热插拔的设备(USB，HDMI)等，则是先注册驱动，当设备插入时才注册设备，匹配驱动执行

### interview-01-010

简述下Linux中断机制，注册和注销中断的相关函数。中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动。

1. Linux中断机制是指当CPU在执行程序的过程中，出现了某些突发事件急待处理时，CPU会暂停当前程序的执行，转去处理突发事件，处理完毕后又返回原程序被中断的位置继续执行。对于Linux中断，一般由外设模块触发，上报对应的中断控制器GIC，最终由相应的CPU内核进行处理
2. 注册和注销中断的相关函数主要有request_irq和free_irq，其中request_irq函数用于向内核注册一个中断处理函数，free_irq函数用于注销一个已经注册的中断处理函数
3. 中断是CPU处于被动状态下来接受设备的信号，具有即时响应和高效利用CPU的优点，轮询则是CPU主动去查询设备是否有请求，实现相对简单。大部分设备请求频率较低，适合使用中断的方式请求；对于频繁请求CPU的设备或者有大量数据请求的网络设备，可能需要CPU频繁地处理数据，轮询反而效率更高。

### interview-01-011

IRQ(Interrupt Request)和FIQ(Fast Interrupt Request)在CPU实现中有什么区别。

1. 优先级。FIQ具有更高的优先级，当FIQ发生时，CPU会在当前指令执行完成后立即响应FIQ中断，而忽略其他IRQ中断
2. 上下文保存。FIQ模式会保存完整的CPU上下文，包括更多的寄存器状态，以确保在中断处理完成后能够恢复到正确的执行状态。以确保在中断处理完成后能够恢复到正确的执行状态
3. 使用场景。IRQ适用于一般性的外部设备中断处理，如定时器中断、串口中断、按键中断等；FIQ适用于对实时性要求非常高的事件处理，如快速的数据传输、紧急的硬件错误处理、实时操作系统中的任务调度等
4. IRQ中断处理程序相对简单，因为它可以使用通用的寄存器和堆栈，并且可以在中断处理程序中调用其他函数。FIQ中断处理程序相对复杂，因为它需要使用专门的寄存器和堆栈，并且不能在中断处理程序中调用其他函数，否则会破坏寄存器和堆栈的状态

### interview-01-012

中断的为啥分上半部分和下半部分，讲下如何实现。

1. 中断分为上半部分和下半部分主要是为了提高系统效率和响应性，同时尽量减少中断处理对其他任务的干扰。这种设计允许中断处理程序快速响应中断并处理最关键和紧急的任务（上半部），而将那些不那么紧急或耗时的任务推迟到稍后执行。
2. 上半部是中断处理的第一阶段，它通常在硬件中断触发后立即执行。上半部的主要任务是：尽快响应中断，处理最关键和紧急的任务，必须在中断上下文中执行，执行速度要快，不能阻塞（如不能调用睡眠函数），不能抢占（不会被其他中断打断）。
3. 下半部是在中断响应结束后执行的，它负责处理那些不那么紧急的任务。下半部可以延迟执行，因此可以在更合适的时机被调度。下半部可以使用软中断，tasklet，workqueue等实现

### interview-01-013

linux内核里面，内存申请相关的函数，功能和区别说明。

1. kmalloc函数，用于内核空间申请较小内存(通常不超过128KB)，分配的内存在物理上是连续的，虚拟地址上自然也是连续的。其中flag指定内存分配的特性，GFP_KERNEL（进程可以睡眠，适用于进程上下文）、GFP_ATOMIC（进程不能睡眠，适用于中断处理函数、tasklet等原子上下文）等
2. kzalloc函数，与kmalloc()类似，但分配的内存块会被初始化为0
3. vmalloc函数，用于分配大块内存，分配的虚拟内存是连续的，但物理内存可以不连续
4. get_free_pages和__get_free_page函数，用于分配特定数量的连续物理页（以2的幂为单位）
5. alloc_pages和 __alloc_pages函数，这些函数返回一个指向struct page结构体的指针列表，该结构体包含了关于分配页面的更多信息。这通常用于更底层的内存管理操作。
6. alloc_page和 __alloc_page函数，分配一个单独的物理页，并返回一个指向struct page的指针

### interview-01-014

驱动使用什么函数接口访问绝对物理地址，为什么需要。

1. 驱动中使用ioremap函数将物理地址映射到内核的虚拟地址空间中，使得内核可以通过虚拟地址来访问物理内存。
2. 现代操作系统中，为了提供进程隔离、隐藏内存细节、增强可扩展性和提供存储保护，通常都会引入内存管理单元（MMU）。MMU的主要功能包括虚拟到物理地址的转换和内存保护。在启用MMU的系统中，内核中操作的都是虚拟地址，而不是物理地址。要访问物理内存，就必须先将物理地址映射为虚拟地址。内核不能直接访问物理地址空间，而需要通过某种机制将物理地址映射到内核地址空间中，然后才能对物理内存进行访问。

```c
void __iomem *iomem; // 映射物理内存到虚拟地址空间
iomem = ioremap(DEVICE_PHYS_ADDR, DEVICE_SIZE);
```

### interview-01-015

在u-boot烧录进去后，上电后串口上没有任何输出，硬件和软件各应该去检查什么？

硬件上检查如下。

1. 控制启动的拨码开关或电平是否正确(一般烧录时和加载时是不一致的)，判断从正确的地址加载u-boot
2. 检测CPU，DRAM和存储的的供电是否正常
3. 检查串口的连接，是否连接正确的引脚，相关器件是否正常

软件上的检查

1. 检查设备树中指定调试的串口和硬件上是否一致
2. 如果一致，在include/common.h中增加DEBUG宏定义，打印更早的系统信息，再进行分析
3. 检查软件串口的设置是否和U-Boot中配置一致，波特率，数据位，停止位，奇偶校验位配置

### interview-01-016

描述下Linux系统的启动流程，有没有优化过启动流程的经历，有说明下步骤，没有则按照经验描述下。

Linux的启动流程如下。

- 引导加载程序启动(U-Boot)
  - 上电和复位后，首先执行加载引导程序U-Boot，
  - 引导加载程序，初始化硬件设备，设置系统时钟，加载内核镜像到内存中，并跳转执行。
- 内核启动(Kernel)
  - 内核加载到内存中，执行内核的初始化代码
  - 内核初始化硬件设备，包含CPU、内存、中断控制器、定时器等
  - 内核挂载根文件系统，执行进一步加载程序
- 文件系统挂载载和执行(Rootfs)
  - 内核挂载文件系统后，后首先执行init进程
  - init进程会加载系统的基本服务(列在/etc/inittab中)，如网络服务，文件系统服务，进程管理等，以及初始化脚本(/etc/init.d/rcS)

对于启动流程优化，一般指从系统上电，到正式程序加载的时间，包含U-Boot的启动时间，内核启动时间，必要服务的加载时间，然后开始执行应用，对于启动时间的优化，主要在于分析主要的耗时点，对应解决。

1. U-Boot的加载时间很短，不过在结束时有bootdelay，会进行延时等待，可以在正式版编译时U-Boot时修改为0
2. Kernel的加载时间主要是必要的组件和驱动加载，其中必要的组件因为功能需求很难优化，可以优化驱动的加载，裁剪未使用的模块，例如如果内核未使用rtc，can这类解决，都可以在configs/中注释，并将对应的设备树状态设置为disable
3. 文件系统的优化，对于QT构成的应用，可以直接使用buildroot这类简单的文件系统(不要选则debain，ubuntu这类复杂系统)，在必要的服务和驱动加载后，就可以执行程序

### interview-01-017

有没有修改过系统启动中的Logo，实现过开机进度条，简述下实现方法。

系统启动过程中，对于U-Boot，Kernel，以及文件系统都可以实现添加自己的Logo，实现的方法如下所示。

- U-Boot中的logo是在编译过程中链接到固件中，运行时从指定地址加载的
  - 在U-Boot环境变量中通过splashimage变量指定地址
  - 在编译U-Boot时通过tools/bmp_logo工具生成include/bmp_logo_data.h，启动时复制到splashimage地址，之后加载显示
  - 修改图片则需要替换tools/logos/*下对应图片，即可在运行时替换显示
- kernel中的logo也是直接链接到固件中，定义在drivers/video/logo目录下
  - 选中和频率分辨率一致的图片，通过命令行转换成ppm格式
  - 添加到drivers/video/logo目录下，并添加同目录下的logo.c代码中，并修改配置项和Makefile，选中添加的logo
  - 重启设备，此时添加的logo就会显示
- 文件系统时应用已经执行，这个步骤一般加载的是启动动作条，而非logo，可以通过如下方式实现
  - 移植splash开机进度条软件，通过命令实现启动动作条
  - 使用QT通过logo图片加动作进度的方式实现开机进度条

上面只是对logo的修改大致方法进行说明，详细的实现还需要根据版本进行调整，但原理都是一致的。

### interview-01-018

是否进行过u-boot和内核的适配，主要进行了哪些工作。

关于u-boot的适配，主要进行了官方SDK对产品硬件的适配，主要工作内容。

1. 确定官方SDK对应开发板和产品硬件的差异，确定需要修改的内容
2. 修改arch/arm/dts下的设备树文件，来适配硬件内容
3. 在board/目录下仿照官方的硬件平台，实现对应自己的平台的硬件文件
4. 修改configs/目录下的默认配置文件，定义u-boot支持的功能
5. 通过make menuconfig，在UI界面中配置和裁剪需要的功能，编译下载既是适配后的U-Boot

关于kernel的适配，和u-boot流程类似。

1. 确定官方SDK对应开发板和产品硬件的差异，确定需要修改的内容
2. 修改arch/arm/boot/dts下的设备树文件，来适配硬件内容
3. 修改arch/arm/configs下的配置文件，定义kernel支持的功能
4. 通过make menuconfig，在UI界面中配置和裁剪需要的功能，编译下载既是适配后的kernel

### interview-01-019

什么是内存屏障。常见的内存屏障有哪些，应用场景是什么。

内存屏障（Memory Barrier）是一种硬件或软件机制，用于确保特定的内存操作按照预期的顺序执行。在多处理器系统或多线程环境中，由于处理器和编译器的优化，内存操作的执行顺序可能与程序代码中的顺序不一致，这可能导致数据竞争和其他并发问题。内存屏障的作用就是强制内存操作按照特定的顺序执行，从而保证程序的正确性。对于ARM核来说，内存屏障的实现方法主要基于DMB(数据内存屏障)，DSB(数据同步屏障)和DIB(指令同步屏障)。

常见的内存屏障有读屏障，写屏障和全屏障。

内存屏障主要应用场景如下所示。

1. 多线程编程，确保共享变量的读写操作按照正确的顺序执行，避免数据竞争
2. 硬件设备驱动，确保对硬件寄存器的读写操作按照正确的顺序执行，避免硬件错误
3. 编译器优化中，防止对内存操作的重排序，保证程序的正确性

## linux-app

### interview-02-001

堆和栈的分别是什么，它们的操作效率上谁更快。

堆是一种动态分配的内存区域，用于存储程序运行时动态分配的数据。堆的内存分配和释放由程序员手动控制，通常使用malloc、calloc、realloc等函数进行内存分配，使用free函数进行内存释放，在C++中是new/delete, new[]/delet[]。堆的内存空间是不连续的，因此分配和释放内存的操作相对较慢。

栈是一种自动分配和释放的内存区域，用于存储函数调用时的局部变量、参数、返回地址等信息。栈的内存分配和释放由编译器自动管理，遵循先进后出（FILO）的原则。栈的内存空间是连续的，因此分配和释放内存的操作相对较快。

### interview-02-002

常见的内存分配方式有哪些。

1. 静态内存分配，在程序编译时就确定了所需内存空间的大小，并在程序运行期间固定不变。适用于程序中所需内存大小在编译时可以确定的情况，如全局变量、静态变量等
2. 栈内存分配，由编译器自动管理，用于存储函数调用时的局部变量、参数、返回地址等信息。适用于函数内部的临时变量、函数调用时的参数传递等场景。
3. 堆内存分配，由程序员手动控制，用于存储程序运行时动态分配的数据。适用于程序中需要动态分配内存的情况，如动态数组、链表、树等数据结构的创建和管理

### interview-02-003

linux应用中的同步机制有哪些。

1. 互斥锁，互斥锁是一种用于保护共享资源的同步机制，确保同一时间只有一个线程可以访问该资源。
2. 条件变量，条件变量是一种用于线程间同步的机制，允许线程在满足特定条件时被唤醒。线程可以等待条件变量满足某个条件，当条件满足时，其他线程可以通过信号通知等待的线程继续执行。
3. 信号量，信号量是一种用于控制对共享资源的访问的同步机制，它可以用来保护临界区，确保同一时间只有一个线程可以访问共享资源。
4. 读写锁，读写锁是一种用于保护共享资源的同步机制，它允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。
5. 屏障（Barrier），屏障是一种用于线程间同步的机制，它允许线程等待其他线程到达某个点，然后再继续执行。
6. 原子操作（atomic operations），原子操作是一种不可中断的操作，它可以确保对共享变量的操作是原子性的，即要么全部执行成功，要么全部不执行。

### interview-02-004

linux应用进程间通讯机制。

1. 管道，包含匿名管道(pipe)和命名管道(fifo)，其中匿名管道用于父子进程间的访问通讯，命名管道则既可以用于父子进程，也可以支持任意进程间的访问通讯
2. 信号，信号是比较复杂的通信方式，用于通知接收进程有某种事件发生，通过signal处理相应的信号
3. 消息队列，消息队列是消息的链接表，包括POSIX消息队列(mq_open/.../mq_close)和System V消息队列(msgget/.../msgrcv)。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。
4. 共享内存，共享内存使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。它通常与其他通信机制（如信号量）结合使用，来达到进程间的同步及互斥。
5. 信号量，信号量(semperature)是一种在进程间或同一进程的不同线程间提供同步的机制。它主要用于控制对共享资源的访问，以确保资源的一致性和避免竞争条件
6. 套接字，套接字是更为一般的进程间通信机制，可用于不同机器之间的进程间通信
7. 文件，文件在Linux系统中是一种基本的持久化存储机制，也可用于进程间通信。进程之间可以通过读写同一文件来交换数据

### interview-02-005

简述下进程，线程和协程的定义。

1. 进程是资源调度的基本单位，运行一个可执行程序会创建一个或者多个进程，进程是拥有资源的基本单位，每个进程都有独立的内存空间、代码以及数据栈等资源。一个进程内多个线程可以并发，多个进程也可以并发
2. 线程是进程中实际执行任务的最小单位，同一进程中的多个线程共享进程的资源，例如内存、文件描述符等。线程是CPU调度的基本单位
3. 协程是一种用户级的轻量级线程，具有自己的寄存器上下文和调度器，在单个线程中实现多个协程间的切换。它不是由操作系统内核所管理，而是完全由程序所控制（在用户态执行）

### interview-02-006

简述下并发和并行。

1. 并发，在同一个CPU核上，基于调度算法，实现进程基于时间交替执行，多个线程看起来同时执行。并发是一种逻辑上的概念，它允许程序中的多个任务在看似同时的情况下进行。
2. 并行，并行是指两个或多个任务在同一个时间段内同时执行，即这些任务在物理上是同时进行的。并行是一种物理上的概念，它要求程序中的多个任务在真正的同时执行。

### interview-02-007

说明下堵塞和非堵塞，同步和异步的理解。

在Linux应用程序开发中，阻塞（Blocking）和非阻塞（Non-blocking），以及同步（Synchronous）和异步（Asynchronous）是描述I/O操作行为的重要概念。

堵塞: 当一个进程调用一个阻塞的I/O操作时，该进程会被挂起（即进入睡眠状态），直到I/O操作完成。在I/O操作完成之前，进程无法执行其他任务
非堵塞: 当一个进程调用一个非阻塞的I/O操作时，如果操作不能立即完成，函数会立即返回一个错误码（如EAGAIN或EWOULDBLOCK），而不会挂起进程。进程可以继续执行其他任务，然后在稍后的时间再次尝试I/O操作
同步: 在同步I/O操作中，进程发起一个I/O操作后会一直等待，直到I/O操作完成。同步I/O可以是阻塞的，也可以是非阻塞的。如果是阻塞的，进程会在I/O操作完成之前一直挂起；如果是非阻塞的，进程会不断轮询I/O操作的状态，直到操作完成。
异步: 在异步I/O操作中，进程发起一个I/O操作后不会等待操作完成，而是继续执行其他任务。当I/O操作完成时，操作系统会通知进程（通常通过信号或回调函数），异步一定是非堵塞的。

阻塞与非阻塞：描述的是I/O操作是否会导致进程挂起。
同步与异步：描述的是I/O操作完成后，进程是否需要等待通知

### interview-02-008

Linux系统的任务调度的算法有哪些。

1. 先来先服务 -- 非抢占式，按照请求的顺序调度
2. 短作业优先 -- 非抢占式，按照估计运行时间最短来调度
3. 最短运行时间优先 -- 抢占式，按剩余运行时间进行调度
4. 时间片轮转 -- 所有进程按照FCFS的原则排列，每次调度，把CPU时间分配给队首的进程
5. 优先级调度 -- 进程分配优先级，按照优先级进行调度
6. 多级反馈队列 -- 设置多个队列，采用不同的时间片，从而满足多个时间片工作的进程需求(时间片轮转+优先级调整)。

### interview-02-009

C++程序生成可执行文件的步骤有哪些。

1. 预处理，处理宏定义，展开头文件，删除注释
2. 编译，将预处理后的文件转换成汇编代码
3. 汇编，将汇编代码转换成二进制机器码
4. 链接，将多个目标文件链接成一个可执行文件

### interview-02-010

什么是静态链接和动态链接。如何生成静态链接库和动态链接库。

静态链接是在编译时将所有目标文件和库文件合并成一个可执行文件的过程。在静态链接中，链接器会将程序所需的所有库函数和数据复制到最终的可执行文件中。这意味着可执行文件在运行时不需要依赖外部的库文件，因为所有必要的代码和数据都已经包含在其中。使用ar命令，可以生成静态库。

```shell
# 通过ar命令生成静态库
gcc -c test.c -o test.o
ar rcs libtest.a test.o

# 使用静态库链接生成程序
gcc main.c libtest.a -o file
```

动态链接是在程序运行时才将库文件加载到内存中的过程。在动态链接中，链接器不会将库文件的代码复制到可执行文件中，而是在可执行文件中记录对库函数的引用。当程序运行时，操作系统会加载所需的库文件，并将其映射到内存中。

```shell
# 通过ar命令生成静态库
gcc -c -fPIC test.c -o test.o
gcc -shared -o libtest.so test.o

# 使用动态库链接生成程序
# gcc中-Wl,-rpath会指定程序链接时查找的目录，否则动态库放在目录下也会查找不到
gcc main.c -Wl,-rpath=. -L. -ltest -o file
```

### interview-02-011

虚拟内存的目的包含哪些方面。

1. 扩展物理内存。虚拟内存允许操作系统将磁盘空间作为内存的扩展，使得程序可以使用比实际物理内存更大的地址空间
2. 内存管理的灵活性。虚拟内存提供了一种灵活的内存管理方式。操作系统可以根据需要将不同的程序和数据加载到物理内存中，而不必担心物理内存的大小限制
3. 内存保护。虚拟内存通过将内存划分为不同的区域，并为每个区域分配不同的权限，实现了内存保护
4. 内存共享。虚拟内存允许多个程序共享相同的物理内存区域。这对于实现进程间通信和资源共享非常有用
5. 内存映射。虚拟内存可以将文件映射到内存中，使得文件可以像内存一样进行读写操作，提高文件操作的效率
6. 内存压缩。一些操作系统还支持虚拟内存的压缩技术，通过压缩内存中的数据来减少内存的占用，从而可以在有限的物理内存中运行更多的程序。

### interview-02-012

linux进程中止的方法.

1. 从main返回
2. 调用exit函数
3. 调用_exit函数
4. 通过信号中止，常见的信号包含SIGTERM和SIGKILL(kill命令发送)
5. 通过异常中止
6. 通过系统调用abort中止，产生SIGABRT信号
7. 最后一个线程调用pthread_exit函数，结束进程

### interview-02-013

描述下Linux页面置换算法。

1. 最优置换算法（Optimal Replacement，OPT），选择将来不再使用的页面或者在最远的将来才被访问的页面进行置换
2. 先进先出算法（First-In-First-Out，FIFO），选择最早加载到内存中的页面进行置换
3. 最近最少使用算法（Least Recently Used，LRU），选择最近最久没被访问的页面进行置换
4. 时钟算法（Clock Algorithm），是LRU算法的一种近似算法。它将所有的页面按照进入内存的先后次序用链接指针链成一个循环队列，用一个指针指向该队列。进行页面置换时，操作系统扫描该循环队列，查找第一个访问位被置为0的页用于置换
5. 改进的时钟算法，在时钟算法的基础上，为每个页面增设一个修改位，用于记录页面是否被修改过。在选择用于置换的页时，把既未访问过又未修改过的页面作为首选

### interview-02-014

内存碎片产生的原因，如何避免内存碎片。

内存碎片是指内存中存在的小块未使用内存，这些小块内存由于太小而无法满足程序的内存分配请求，导致内存利用率降低。内存碎片主要分为两种类型：外部碎片和内部碎片。

- 外部碎片是指内存中存在的未使用内存块，但这些内存块由于太小而无法满足程序的内存分配请求，主要原因是频繁的内存分配和释放操作或内存分配算法的不合理
- 内部碎片是指程序分配的内存块中未使用的部分，内存分配的粒度问题以及内存对齐要求

避免内存碎片的方法。

1. 选择合适的内存分配和释放策略
2. 使用内存管理工具
3. 应用层使用内存池，合理设计数据结构

### interview-02-015

什么是守护进程，守护进程如何创建的。

守护进程是一种在后台运行的特殊进程，它通常在系统启动时自动启动，并在系统关闭时自动关闭。守护进程不与任何终端关联，因此用户无法直接与它们进行交互。守护进程通常用于执行系统级任务，如网络服务、日志记录、定时任务等。通过创建子进程、脱离终端、改变工作目录、重设文件权限掩码、关闭文件描述符等步骤，可以创建一个守护进程。

守护进程的创建方式如下所示。

```c
void daemonize(void) {
    pid_t pid;

    // 创建子进程
    pid = fork();
    if (pid < 0) {
        perror("fork");
        exit(1);
    } else if (pid > 0) {
        // 父进程退出
        exit(0);
    }

    // 子进程成为新的会话组长
    if (setsid() < 0) {
        perror("setsid");
        exit(1);
    }

    // 改变工作目录到根目录
    if (chdir("/") < 0) {
        perror("chdir");
        exit(1);
    }

    // 重设文件权限掩码
    umask(0);

    // 关闭所有不需要的文件描述符
    int fd;
    for (fd = sysconf(_SC_OPEN_MAX); fd > 0; fd--) {
        close(fd);
    }

    // 打开系统日志
    openlog("my_daemon", LOG_PID, LOG_DAEMON);
    syslog(LOG_INFO, "Daemon started");
}

//Linux系统中也封装了此函数。
#include <unistd.h>

// @nochdir：如果该参数为0，则守护进程将改变其工作目录到根目录（/）；如果该参数为非0，则守护进程将保持其当前工作目录。
// @noclose：如果该参数为0，则守护进程将关闭所有打开的文件描述符（包括标准输入、标准输出和标准错误）；如果该参数为非0，则守护进程将保持所有文件描述符打开
int daemon(int nochdir, int noclose);
```

注意：守护进程是后台运行的特殊进程，但后台进程并不一定是守护进程，所以"程序 &"只是后台进程，而并非守护进程。

### interview-02-016

什么是僵尸进程和孤儿进程，讲述下产生原因，以及解决办法。

- 僵尸进程

僵尸进程是指已经完成执行（通过调用exit()系统调用）但在进程表中仍然有一个条目的进程。

当一个子进程先于其父进程结束时，子进程会变成僵尸进程。这是因为父进程需要通过wait()或waitpid()系统调用来获取子进程的退出状态。如果父进程没有调用这些函数，子进程就会一直保持僵尸状态。

解决方法: 父进程调用wait()或waitpid()：父进程通过调用这些函数来获取子进程的退出状态，从而使子进程彻底结束

- 孤儿进程

孤儿进程是指父进程先于子进程结束，从而使子进程成为一个没有父进程的进程。

当父进程结束时，子进程会被init进程（PID为1的进程）收养，init进程会成为子进程的新父进程

孤儿进程会被init进程管理和清理，因此不需要特别的处理。
